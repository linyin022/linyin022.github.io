<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PHP面试题</title>
    <link href="/2022/08/01/PHP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/08/01/PHP%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a>编程基础</h2><h4 id="cookie和session的区别是什么"><a href="#cookie和session的区别是什么" class="headerlink" title="cookie和session的区别是什么"></a>cookie和session的区别是什么</h4><ol><li>cookie不是很安全，别人可以分析你存放在本地的cookie进行欺骗，考虑到安全性最好使用session</li><li>session 在一定时间内是保存在服务器上的不过当访问越来越多时会比较占用服务器端性能资源 考虑到减轻资源新能方面我们最好用cookie</li><li>当个cookie保存数据时有限的一般不超过4kb 很多浏览器都限制站点最多保存20个cookie 而session 保存在服务器端 没有数据量的限制 可以保存更复杂的类型</li><li>二者的生命周期有明显的区别，cookie的生命周期是累计的而session是间隔的。</li></ol><h4 id="get和post的方法有什么区别"><a href="#get和post的方法有什么区别" class="headerlink" title="get和post的方法有什么区别"></a>get和post的方法有什么区别</h4><ol><li>二者参数位置get在url里post在请求体中</li><li>get能被浏览器所缓存而post不能被缓存的</li><li>get参数长度受限最大2048个字符而post不受限</li><li>get因为放在url里安全较差而pos的请求参数放在body里安全性线对较好</li><li>get请求可以通过浏览器直接访问支持刷新和后退而post请求不能被浏览器问，刷新后数据需要重新传送。</li></ol><h4 id="什么是http和https"><a href="#什么是http和https" class="headerlink" title="什么是http和https"></a>什么是http和https</h4><ul><li>http协议传输的数据都是未加密的明文的因此使用http协议加密传输，隐私的信息是非常不安全的，为了保证这些隐私信息的加密安全就诞生了https协议</li><li>https是由ssl+http协议构建的 可以进行加密传输 身份证的网络协议要比http协议更加安全 https协议主要有两个作用：建立信息安全通过，用来保证数据传输的安全性，第二呢就是确定网站的真实性</li></ul><h4 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h4><ol><li>http不需要证书而https需要证书申请ca证书需要一定的费用成本</li><li>http下的信息是明文传输的而https协议是由ssl+http协议构建的可进行加密传输身份认证网络协议可以防止网络传输内容被窃取篡改</li><li>http和https使用的是完全不同的链接方式所以他们的端口也不一样 前者是80端口后者是443端口</li></ol><h4 id="Socket是什么"><a href="#Socket是什么" class="headerlink" title="Socket是什么"></a>Socket是什么</h4><p><strong>socket（套接字）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I&#x2F;O插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是IP地址与端口的组合。</strong></p><p>以供用户在设计网络应用程序时根据不同的要求来选择套接字有三种类型：<strong>流式套接字</strong>（SOCK-STREAM）、数据<strong>报套接字</strong>（SOCK-DGRAM）和<strong>原始套接字</strong>（SOCK-RAW）。</p><ol><li><p>流式套接字。它提供了一种可靠的、面向连接的双向数据传输服务，实现了数据无差错、无重复的发送。流式套接字内设流量控制，被传输的数据看作是无记录边界的字节流。在TCP&#x2F;IP协议簇中，使用TCP协议来实现字节流的传输，当用户想要发送大批量的数据或者对数据传输有较高的要求时，可以使用流式套接字。</p></li><li><p>数据报套接字。它提供了一种无连接、不可靠的双向数据传输服务。数据包以独立的形式被发送，并且保留了记录边界，不提供可靠性保证。数据在传输过程中可能会丢失或重复，并且不能保证在接收端按发送顺序接收数据。在TCP&#x2F;IP协议簇中，使用UDP协议来实现数据报套接字。在出现差错的可能性较小或允许部分传输出错的应用场合，可以使用数据报套接字进行数据传输，这样通信的效率较高。</p></li><li><p>原始套接字。该套接字允许对较低层协议（如IP或ICMP）进行直接访问，常用于网络协议分析，检验新的网络协议实现，也可用于测试新配置或安装的网络设备。</p></li></ol><p><strong>Socket应用场景</strong>：</p><ul><li>浏览器进程与web服务器进程通信；</li><li>QQ进程与好友的QQ进程通信</li></ul><h4 id="什么是高并发"><a href="#什么是高并发" class="headerlink" title="什么是高并发"></a>什么是高并发</h4><p><strong>通俗来讲，高并发是指在同一个时间点，有很多用户同时的访问同一 API 接口或者 Url 地址。它经常会发生在有大活跃用户量，用户高聚集的业务场景中。</strong></p><p>举个例子：高速路口，1秒钟来5部车，每秒通过5部车，高速路口运作正常。突然，这个路口1秒钟只能通过4部车，车流量仍然依旧，结果必定出现大塞车。（5条车道忽然变成4条车道的感觉）</p><p>同理，某一个秒内，20*500个可用连接进程都在满负荷工作中，却仍然有1万个新来请求，没有连接进程可用，系统陷入到异常状态也是预期之内。</p><p>某个抢购场景中，共有100个商品，最后一刻，已经消耗了99个商品，剩最后一个。这个时候，系统发来多个并发请求，这批请求读取到的商品余量都是99个，然后都通过了这一个余量判断，最终导致超发。（同文章前面说的场景）</p><p><strong>高并发网站的解决方案</strong></p><ol><li>前端优化（CND加速、建立独立图片服务器）</li><li>服务端优化（页面静态化、并发处理[异步|多线程]、队列处理）</li><li>数据库优化（数据库缓存[Memcachaed|Redis]、读写分离、分库分表、分区）</li><li>Web服务器优化（负载均衡、反向代理）</li></ol><h4 id="TCP-和UDP-的特点和区别"><a href="#TCP-和UDP-的特点和区别" class="headerlink" title="TCP 和UDP 的特点和区别"></a>TCP 和UDP 的特点和区别</h4><ol><li><strong>都是属于传输层协议</strong></li><li><strong>TCP</strong><ol><li>面向连接，所以只能一对一</li><li>面向字节流传输</li><li>数据可靠，不丢失</li><li>全双工通信</li></ol></li><li><strong>UDP</strong>（根据TCP特点反记）<ol><li>无连接，支持一对一，一对多，多对多</li><li>面向保温传输</li><li>首部开销小，数据不一定可靠但是速度更快</li></ol></li></ol><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p><strong>1、状态码分类</strong></p><ul><li>- 1xx：信息，服务器收到请求，需要请求者继续操作</li><li>- 2xx：成功</li><li>- 3xx：重定向</li><li>- 4xx：客户端错误</li><li>- 5xx：服务端错误</li></ul><p><strong>2、常用状态码</strong></p><ul><li>200：请求成功</li><li>301：永久重定向</li><li>302：临时移动</li><li>400 bad request：客户端请求语法错误</li><li>401 unauthorized：客户端没有权限</li><li>403 forbidden：服务器拒绝客户端请求</li><li>404 not found：客户端请求资源不存在</li><li>500 Internal Server Eerro：服务器内部错误</li><li>502 bad gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应</li><li>503 Service Unavailable 超载或系统维护</li><li>504 Gateway timeout：网关超时</li></ul><h4 id="如何理解MVC"><a href="#如何理解MVC" class="headerlink" title="如何理解MVC"></a>如何理解MVC</h4><p><strong>MVC是一个框架模式，它强制性的使应用程序输入、处理和输出分开。</strong><br><strong>M</strong>:  代表就是具体的模型(model)主要作用就是与数据库进行数据交互<br><strong>V</strong>：代表就是具体的视图（view）主要作用就是与用户进行数据交互<br><strong>C</strong>：代表就是具体的控制器（controller）主要作用代表了处理具体的业务逻辑</p><h4 id="ThinkPHP如何防止SQL注入"><a href="#ThinkPHP如何防止SQL注入" class="headerlink" title="ThinkPHP如何防止SQL注入"></a>ThinkPHP如何防止SQL注入</h4><ol><li>查询条件尽量使用数组方式，这是更为安全的方式；</li><li>如果不得已必须使用字符串查询条件，使用预处理机制；</li><li>开启数据字段类型验证，可以对数值数据类型做强制转换；<ol><li>版本开始已经强制进行字段类型验证了</li></ol></li><li>使用自动验证和自动完成机制进行针对应用的自定义过滤；</li><li>使用字段类型检查、自动验证和自动完成机制等避免恶意数据的输入。</li></ol><h2 id="PHP基础"><a href="#PHP基础" class="headerlink" title="PHP基础"></a>PHP基础</h2><h3 id="文件图片问题"><a href="#文件图片问题" class="headerlink" title="文件图片问题"></a>文件图片问题</h3><h4 id="FILES-是什么意思？"><a href="#FILES-是什么意思？" class="headerlink" title="$ _FILES 是什么意思？"></a><code>$ _FILES</code> 是什么意思？</h4><p><code>$_FILES</code> 是一个包含通过 HTTP POST 方式上传到当前脚本的项目的数组。</p><h4 id="FILES-39-userfile-39-39-name-39-和-FILES-39-userfile-39-39-tmp-name-39-有什么区别"><a href="#FILES-39-userfile-39-39-name-39-和-FILES-39-userfile-39-39-tmp-name-39-有什么区别" class="headerlink" title="$ _FILES [&#39;userfile&#39;] [&#39;name&#39; ] 和 $ _FILES [&#39;userfile&#39;] [&#39;tmp_name&#39;] 有什么区别"></a><code>$ _FILES [&#39;userfile&#39;] [&#39;name&#39; ]</code> 和 <code>$ _FILES [&#39;userfile&#39;] [&#39;tmp_name&#39;]</code> 有什么区别</h4><p><code>$ _FILES [&#39;userfile&#39;] [&#39;name&#39;]</code> 表示客户端文件的原始名称，</p><p><code>$_FILES[&#39;userfile&#39;][&#39;tmp_name&#39;]</code> 表示服务器上存储的文件的临时文件名。</p><h4 id="上传文件出问题时，如何获取错误信息"><a href="#上传文件出问题时，如何获取错误信息" class="headerlink" title="上传文件出问题时，如何获取错误信息"></a>上传文件出问题时，如何获取错误信息</h4><p><code>$_FILES[&#39;userfile&#39;][&#39;error&#39;]</code> 包括了与上传文件有关的错误代码。</p><h4 id="如何更改要上传的文件大小的最大值"><a href="#如何更改要上传的文件大小的最大值" class="headerlink" title="如何更改要上传的文件大小的最大值"></a>如何更改要上传的文件大小的最大值</h4><p>可通过更改 <code>php.ini</code> 中的 <code>upload_max_filesize</code> 来更改要上传的文件的最大大小。</p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="PHP-是什么"><a href="#PHP-是什么" class="headerlink" title="PHP 是什么"></a>PHP 是什么</h4><p>PHP 是一种基于脚本的 web 语言，开发者可以动态的创建网页。</p><h4 id="PHP-的全称"><a href="#PHP-的全称" class="headerlink" title="PHP 的全称"></a>PHP 的全称</h4><p>Hypertext Preprocessor（超文本预处理器）</p><h4 id="PHP-是否支持多重继承"><a href="#PHP-是否支持多重继承" class="headerlink" title="PHP 是否支持多重继承"></a>PHP 是否支持多重继承</h4><p>PHP 只支持单继承。PHP 的类使用关键字 <code>extends</code> 继承另一个类</p><h4 id="使用-final-修饰的类和方法代表什么意思"><a href="#使用-final-修饰的类和方法代表什么意思" class="headerlink" title="使用 final 修饰的类和方法代表什么意思"></a>使用 <code>final</code> 修饰的类和方法代表什么意思</h4><p><code>final</code> 是在 PHP5 版本引入的，它修饰的类不允许被继承，它修饰的方法不允许被重写。</p><h4 id="PHP-和-HTML-是如何交互的"><a href="#PHP-和-HTML-是如何交互的" class="headerlink" title="PHP 和 HTML 是如何交互的"></a>PHP 和 HTML 是如何交互的</h4><p>PHP 和 Javascript 无法直接进行交互，因为 PHP 是一种服务器端语言，而 Javascript 是一种浏览器语言。但是，我们可以交换变量，因为 PHP 可以生成将由浏览器执行的 Javascript 代码，并且可以通过 URL 将特定的变量传递回 PHP。</p><h4 id="获取图片属性（size-width-和-height）的函数是什么"><a href="#获取图片属性（size-width-和-height）的函数是什么" class="headerlink" title="获取图片属性（size, width, 和 height）的函数是什么"></a>获取图片属性（size, width, 和 height）的函数是什么</h4><p>获取图片大小 size：getimagesize ()；获取图片宽度 width：imagesx ()；获取图片高度 height：imagesy ()。</p><h4 id="include-和-require-在执行失败的情况下有什么不同"><a href="#include-和-require-在执行失败的情况下有什么不同" class="headerlink" title="include() 和 require() 在执行失败的情况下有什么不同"></a><code>include()</code> 和 <code>require()</code> 在执行失败的情况下有什么不同</h4><p><code>include()</code> 将会产生一个警告，不影响后续程序的执行。<code>require()</code> 将会产生一个致命错误，后续程序停止执行。</p><h4 id="如何在-PHP-中强制转换类型？"><a href="#如何在-PHP-中强制转换类型？" class="headerlink" title="如何在 PHP 中强制转换类型？"></a>如何在 PHP 中强制转换类型？</h4><p>输出类型的名称必须在要强制转换的变量前的括号中指定，如下所示：</p><ul><li>(int), (integer) - 强制转换为整型</li><li>(bool), (boolean) - 强制转换为布尔值</li><li>(float), (double), (real) - 强制转换为浮点型</li><li>(string) - 强制转换为字符串</li><li>(array) - 强制转换为数组</li><li>(object) - 强制转换为对象</li></ul><h4 id="条件语句何时以-endif-结尾？"><a href="#条件语句何时以-endif-结尾？" class="headerlink" title="条件语句何时以 endif 结尾？"></a>条件语句何时以 endif 结尾？</h4><p>当最初的 if 后面跟着：然后是没有大括号的代码块时。</p><h4 id="SERVER-是什么意思？"><a href="#SERVER-是什么意思？" class="headerlink" title="$ _SERVER 是什么意思？"></a><code>$ _SERVER</code> 是什么意思？</h4><p><code>$_SERVER</code> 是一个包含 Web 服务器创建信息的数组，包括了路径，头部和脚本位置等。</p><h4 id="双引号和单引号的区别"><a href="#双引号和单引号的区别" class="headerlink" title="双引号和单引号的区别"></a>双引号和单引号的区别</h4><ul><li><strong>双引号解释变量，单引号不解释变量</strong></li><li>双引号里插入单引号，其中单引号里如果有变量的话，变量解释</li><li>双引号的变量名后面必须要有一个非数字、字母、下划线的特殊字符，或者用{}讲变量括起来，否则会将变量名后面的部分当做一个整体，引起语法错误</li><li>双引号解释转义字符，单引号不解释转义字符，但是解释’\和\</li><li><strong>能使单引号字符尽量使用单引号，单引号的效率比双引号要高（因为双引号要先遍历一遍，判断里面有没有变量，然后再进行操作，而单引号则不需要判断）</strong></li></ul><h4 id="isset-和-empty-区别"><a href="#isset-和-empty-区别" class="headerlink" title="isset() 和 empty() 区别"></a>isset() 和 empty() 区别</h4><ol><li>sset判断变量是否存在，可以传入多个变量，若其中一个变量不存在则返回假；</li><li>empty判断变量是否为空为假，只可传一个变量，如果为空为假则返回真</li></ol><h4 id="什么事面向对象，主要特征是什么"><a href="#什么事面向对象，主要特征是什么" class="headerlink" title="什么事面向对象，主要特征是什么"></a>什么事面向对象，主要特征是什么</h4><ul><li>面向对象是程序的一种设计方式，它利于提高程序的重用性，使程序结构更加清晰。</li><li>主要特征：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>。如果是4个方面则加上：抽象。</li></ul><p><strong>封装：</strong></p><p>封装是保证软件部件具有优良的模块性的基础,封装的目标就是要实现软件部件的高内聚,低耦合,防止程序相互依赖性而带来的变动影响.</p><p><strong>继承：</strong></p><p>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。</p><p><strong>多态：</strong></p><p>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p><strong>抽象：</strong></p><p>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是抽象。</p><h4 id="PHP遍历数组的6种方式"><a href="#PHP遍历数组的6种方式" class="headerlink" title="PHP遍历数组的6种方式"></a>PHP遍历数组的6种方式</h4><ul><li><p>foreach</p></li><li><p>array_map 是一个匿名函数 返回一个数组 可以同时处理多个数组</p><ul><li>&#96;&#96;&#96;php<br>例子：<br>$arr&#x3D;[1,2,3,4,5,6];<br>$arr&#x3D;array_map(funtion(&amp;$time){<br>return $item;<br>},$arr)<br>echo $arr<br>结果：1，2，3，4，5，6<figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><br>- array_walk 以引用传递的形式遍历数组，没有放回值而且只能处理一个数组<br><br>  - ```php<br>    例子：<span class="hljs-variable">$arr</span>=[1,2,3,4,5,6];<br>    arrat_walk(<span class="hljs-variable">$arr</span>,funtion(&amp;<span class="hljs-variable">$item</span>)&#123;<br>    <span class="hljs-variable">$item</span>=<span class="hljs-variable">$item</span>;<br>    &#125;)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$arr</span><br>    结果：1，2，3，4，5<br></code></pre></td></tr></table></figure></li></ul></li><li><p>for</p></li><li><p>each —-<code>这个函数执行效率不行，已经在PHP7.2更新后被废弃了 </code></p></li><li><p>reset 准确的讲不止reset一个函数，需要组合多个内置函数，平常写代码用不上，根据业务要求才会用上reset</p><ul><li>&#96;&#96;&#96;php<br>例子：$arr&#x3D;[1,2,3,4,5,6];<br>rest($arr)<br>while($value&#x3D;current($arr)){<br>$ar[$key($arr)]&#x3D;value;<br>next($arr);<br>}<br>echo $arr<br>结果：1，2，3，4，5<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### 底层实现是通过散列表（hash table） + 双向链表（解决hash冲突）<br><br>- hashtable：将不同的关键字（key）通过映射函数计算得到散列值（Bucket-&gt;h） 从而直接索引到对应的Bucket<br>- hash表保存当前循环的指针，所以foreach 比for更快<br>- Bucket：保存数组元素的key和value，以及散列值h<br><br>#### 如何保证有序性<br><br><span class="hljs-number">1.</span> 散列函数和元素数组（Bucket）中间添加一层大小和存储元素数组相同的映射表。<br><span class="hljs-number">2.</span> 用于存储元素在实际存储数组中的下标<br><span class="hljs-number">3.</span> 元素按照映射表的先后顺序插入实际存储数组中<br><span class="hljs-number">4.</span> 映射表只是原理上的思路，实际上并不会有实际的映射表，而是初始化的时候分配Bucket内存的同时，还会分配相同数量的 uint32_t 大小的空间，然后将 arData 偏移到存储元素数组的位置。<br><br>#### 解决hash重复(php使用的链表法)<br><br><span class="hljs-number">1.</span> 链表法:不同关键字指向同一个单元时，使用链表保存关键字（遍历链表匹配key）<br><span class="hljs-number">2.</span> 开放寻址法：当关键字指向已经存在数据的单元的时候，继续寻找其他单元，直到找到可用单元（占用其他单元位置，更容易出现hash冲突，性能下降）<br><br><br><br>#### Nginx 和 php 之间的通信<br><br><span class="hljs-number">1.</span> 通信方式：fastcgi_pass<br>   <span class="hljs-number">1.</span> tcp socket<br>      - 跨服务器，nginx和php不在一个机器时，只能用这个方式<br>      - 面向连接的协议，更好的保证通信的正确性和完整性<br>   <span class="hljs-number">2.</span> unix socket<br>      - 不需要网络协议栈、打包拆包等<br>      - 减少tcp 开销，效率比tcp socket 更高<br>      - 高并发时候不稳定，连接数暴增产生大量的长时缓存，大数据包可能直接返回异常<br><br>#### 请说明 PHP 中传值与传引用的区别。什么时候传值什么时候传引用<br><br>**按值传递**：函数范围内对值的任何改变在函数外部都会被忽略<br>**按引用传递**：函数范围内对值的任何改变在函数外部也能反映出这些修改<br>**优缺点**：<br><br>- 按值传递时，php必须复制值。特别是对于大型的字符串和对象来说，这将会是一个代价很大的操作。按引用传递则不需要复制值，对于性能提高很有好处。<br><br>#### 在PHP中error_reporting这个函数有什么作用<br><br>设置PHP的报错级别并返回当前级别。<br><br>#### 在程序的开发中，如何提高程序的运行效率<br><br><span class="hljs-number">1.</span> 优化SQL语句，查询语句中尽量不使用select *，用哪个字段查哪个字段；少用子查询可用表连接代替；少用模糊查询；<br><span class="hljs-number">2.</span> 数据表中创建索引；<br><span class="hljs-number">3.</span> 对程序中经常用到的数据生成缓存。<br><br>#### 对于大流量的网站,您采用什么样的方法来解决访问量问题<br><br><span class="hljs-number">1.</span> 有效使用缓存，增加缓存命中率<br><span class="hljs-number">2.</span> 使用负载均衡<br><span class="hljs-number">3.</span> 对静态文件使用cdn进行存储和加速<br><span class="hljs-number">4.</span> 想法减少数据库的使用<br><span class="hljs-number">5.</span> 查看出现统计的瓶颈在哪里<br><span class="hljs-number">6.</span> 反向代理<br><br>#### 语句include和require的区别是什么?为避免多次包含同一文件，可用什么语句代替它们?<br><br>区别：<br>在失败的时候：<br><br>- include产生一个warning，而require产生直接产生错误中断<br>- require在运行前载入<br>- include在运行时载入<br><br>代替：<br><br>- require_once<br>- include_once<br><br>#### foo()和@foo()之间有什么区别<br><br>@代表所有warning忽略<br><br>#### 简述php的垃圾收集机制<br><br>php中的变量存储在变量容器zval中，zval中除了存储变量类型和值外，还有is_ref和refcount字段。refcount表示指向变量的元素个数，is_ref表示变量是否有别名。如果refcount为<span class="hljs-number">0</span>时，就回收该变量容器。如果一个zval的refcount减<span class="hljs-number">1</span>之后大于<span class="hljs-number">0</span>，它就会进入垃圾缓冲区。当缓冲区达到最大值后，回收算法会循环遍历zval，判断其是否为垃圾，并进行释放处理。<br><br>#### echo、print_r、print、var_dump区别<br><br>echo：语句结构；<br>print：是函数，有返回值<br>print_r：能打印数组，对象<br>var_dump:能打印对象数组，并且带数据类型<br><br>#### 写出smarty模板的特点<br><br>速度快，编译型，缓存技术，插件机制，强大的表现逻辑<br><br>#### PHP如何实现页面跳转<br><br><span class="hljs-number">1.</span> php函数跳转，缺点，header头之前不能有输出，跳转后的程序继续执行，可用exit中断执行后面的程序。<br><span class="hljs-number">2.</span> header(<span class="hljs-string">&quot;Location:网址&quot;</span>);<span class="hljs-comment">//直接跳转</span><br><span class="hljs-number">3.</span> header(<span class="hljs-string">&quot;refresh:3;url=[http://www.jsdaima.com](https://link.zhihu.com/?target=http%3A//www.jsdaima.com)&quot;</span>);<span class="hljs-comment">//三秒后跳转</span><br><span class="hljs-number">4.</span> 利用meta   `echo <span class="hljs-string">&quot;&quot;</span>`;<br><br>#### 如何把一个GB2312格式的字符串装换成UTF<span class="hljs-number">-8</span>格式<br><br>iconv(<span class="hljs-string">&#x27;GB2312&#x27;</span>,<span class="hljs-string">&#x27;UTF-8&#x27;</span>,字符串)<br><br>实例：<br><br>```php<br>&lt;?php<br>header(<span class="hljs-string">&quot;Content-type:text/html;charset=GB2312&quot;</span>);<br>echo $str= <span class="hljs-string">&#x27;你好,这里是gbk转utf8!&#x27;</span>;<br>echo <span class="hljs-string">&#x27;&lt;br /&gt;&#x27;</span>;<br>echo iconv(<span class="hljs-string">&#x27;GB2312&#x27;</span>, <span class="hljs-string">&#x27;UTF-8&#x27;</span>, $str); <span class="hljs-comment">//将字符串的编码从GB2312转到UTF-8</span><br><span class="hljs-comment">// GBK转UTF8同理</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="如果需要原样输出用户输入的内容，在数据入库前，要用哪个函数处理"><a href="#如果需要原样输出用户输入的内容，在数据入库前，要用哪个函数处理" class="headerlink" title="如果需要原样输出用户输入的内容，在数据入库前，要用哪个函数处理"></a>如果需要原样输出用户输入的内容，在数据入库前，要用哪个函数处理</h4><p>htmlspecialchars或者htmlentities</p><h4 id="简述-private、-protected、-public修饰符的访问权限"><a href="#简述-private、-protected、-public修饰符的访问权限" class="headerlink" title="简述 private、 protected、 public修饰符的访问权限"></a>简述 private、 protected、 public修饰符的访问权限</h4><p>private : 私有成员, 在类的内部才可以访问。<br>protected : 保护成员，该类内部和继承类中可以访问。<br>public : 公共成员，完全公开，没有访问限制。</p><h4 id="this和self、parent这三个关键词分别代表什么？在哪些场合下使用"><a href="#this和self、parent这三个关键词分别代表什么？在哪些场合下使用" class="headerlink" title="$this和self、parent这三个关键词分别代表什么？在哪些场合下使用"></a>$this和self、parent这三个关键词分别代表什么？在哪些场合下使用</h4><p>$this 当前对象<br>self 当前类<br>parent 当前类的父类</p><p>$this在当前类中使用,使用-&gt;调用属性和方法<br>self也在当前类中使用，不过需要使用::调用<br>parent在类中使用</p><h4 id="常用的魔术方法有哪些？举例说明"><a href="#常用的魔术方法有哪些？举例说明" class="headerlink" title="常用的魔术方法有哪些？举例说明"></a>常用的魔术方法有哪些？举例说明</h4><p><strong>php规定以两个下划线（）开头的方法都保留为魔术方法，所以建议大家函数名最好不用开头，除非是为了重载已有的魔术方法。</strong></p><ul><li>__construct() 实例化类时自动调用。</li><li>destruct() 类对象使用结束时自动调用。</li><li>__set() 在给未定义的属性赋值的时候调用。</li><li>get() 调用未定义的属性时候调用。</li><li>__isset() 使用isset()或empty()函数时候会调用。</li><li>unset() 使用unset()时候会调用。</li><li>__sleep() 使用serialize序列化时候调用。</li><li>wakeup() 使用unserialize反序列化的时候调用。</li><li>__call() 调用一个不存在的方法的时候调用。</li><li>callStatic()调用一个不存在的静态方法是调用。</li><li>__toString() 把对象转换成字符串的时候会调用。比如 echo。</li><li>invoke() 当尝试把对象当方法调用时调用。</li><li>set_state() 当使用var_export()函数时候调用。接受一个数组参数。</li><li>clone() 当使用clone复制一个对象时候调用。</li></ul><h4 id="如何处理负载，高并发"><a href="#如何处理负载，高并发" class="headerlink" title="如何处理负载，高并发"></a>如何处理负载，高并发</h4><ol><li><p><strong>HTML静态化</strong></p><ul><li>效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的 网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。</li></ul></li><li><p><strong>图片服务器分离</strong></p><ul><li>把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如七牛等</li></ul></li><li><p><strong>数据库集群和库表散列及缓存</strong></p><ul><li>数据库的并发连接为100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。另外尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。</li></ul></li><li><p><strong>镜像</strong></p><ul><li>尽量减少下载，可以把不同的请求分发到多个镜像端。</li></ul></li><li><p><strong>负载均衡</strong></p><ul><li>Apache的最大并发连接为1500，只能增加服务器，可以从硬件上着手，如F5服务器。当然硬件的成本比较高，我们往往从软件方面着手。</li></ul></li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="为什么SQL语句命中索引比不命中索引还要快"><a href="#为什么SQL语句命中索引比不命中索引还要快" class="headerlink" title="为什么SQL语句命中索引比不命中索引还要快"></a>为什么SQL语句命中索引比不命中索引还要快</h4><p>MYSQL InnoDB 索引为例</p><p>虽然，使用索引可以减少磁盘IO次数，提高查询效率，但是，索引也不能建立太多，如果一个表中</p><p>所有字段的索引很大，也会导致性能的下降。</p><h4 id="索引的作用"><a href="#索引的作用" class="headerlink" title="索引的作用"></a>索引的作用</h4><p>索引可以快速的检索我们想要的数据</p><h4 id="在使用索引时要注意几个点"><a href="#在使用索引时要注意几个点" class="headerlink" title="在使用索引时要注意几个点"></a>在使用索引时要注意几个点</h4><ol><li>索引表中的每个字段都会降低写入性能</li><li>建议使用表中的唯一值作为索引字段</li><li>在关系型数据库中充当外键的字段必须建立索引（原因：因为他们可跨多个表进行复杂查询的时候提高性能）</li><li>索引会占用磁盘空间，选择索引的字段要慎重</li></ol><h4 id="表切分-分为几种"><a href="#表切分-分为几种" class="headerlink" title="表切分 分为几种"></a>表切分 分为几种</h4><p><strong>水平切分</strong>：把一章数据为千万级别的大表根据业务主键切分成多张小表，那么这些小表可能达到100张甚至1000张。</p><p><strong>垂直切分</strong>：就是将单表中的多个列按照业务逻辑把它关联性比较大的列放到在同一张表上去</p><h4 id="SQL的执行响应比较慢怎么办？何排查思路"><a href="#SQL的执行响应比较慢怎么办？何排查思路" class="headerlink" title="SQL的执行响应比较慢怎么办？何排查思路"></a>SQL的执行响应比较慢怎么办？何排查思路</h4><p> 有以下四个原因：</p><ol><li>没有索引或者SQL没有命中索引导致索引失效</li><li>单表数据量过多，导致查询瓶颈</li><li>网络原因或者机器本身负载过高</li><li>热点数据导致单点负载不均衡</li></ol><p>针对以上方案的解决方法:</p><ol><li>打开MYSQL的慢程序日志，收集一段时间的慢查询找出耗时最长的SQL语句进行分析 比如可以利用执行计划Explain的去查询SQL是否有命中索引 若没有命中索引 优化SQL语句保证SQL走索引执行 若没办法优化在表上添加索引，（在优化SQL或者添加索引的时候 需要符合最左匹配原则）</li><li>将后缀为0-100的表放在一个数据库实例中然后在将100-200的表放到另一个数据库实例中把1000张表分别放到了10个数据库实例中我们感觉业务逻辑的主键，把请求路由到不同的这个数据实例中去，让每个数据库实例承担对应的流量，这样均摊的流量就是比较小，从而达到性能提升的目的。</li><li>网络原因或者机器负载的情况可以进行读写分离 比如MYSQL支持遗嘱多从的分布式部署，我们可以将主库用来处理写的操作，然后多个从库只处理读的操作，在流量比较大的场景中，可以增加从库提高数据库的负载能力，从而提升数据库的总体性能</li><li>热点数据导致单点数据负载不均衡的情况，这样的情况下对数据本身的调整以外，还可以增加缓存，然后将查询比较频繁的热点数据放到缓存中去Redis ES 等等 来缓解数据库的压力提高数据库的响应速度</li></ol><h4 id="数据库三大范式是什么"><a href="#数据库三大范式是什么" class="headerlink" title="数据库三大范式是什么"></a>数据库三大范式是什么</h4><ul><li>第一每个列都不可以在拆分。</li><li>第二在第一的基础上，非主键列完全依赖于主键，而不能依赖于主键的一部分。</li><li>第三在第二的基础上 ，非主键列只依赖于主键，不依赖于其他非主键。</li></ul><h4 id="MYSQL有关权限表都有几个"><a href="#MYSQL有关权限表都有几个" class="headerlink" title="MYSQL有关权限表都有几个"></a>MYSQL有关权限表都有几个</h4><p>user、db、table_priv、columns、priv、host</p><p>user权限表：记录允许链接数据库的账号信息</p><p>db权限表：记录各个账户在数据库上的操作权限</p><p>table_priv权限表：记录数据表级的操作权限</p><p>columns_priv权限表：记录数据列级的操作权限。</p><p>host权限表：配合db权限表，给主机定下主机数据库级操作权限和更细致的控制，这个权限不受GRANT和RECOKE语句的影响</p><h4 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h4><ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ul><h4 id="SQL语句主要分为哪几类"><a href="#SQL语句主要分为哪几类" class="headerlink" title="SQL语句主要分为哪几类"></a>SQL语句主要分为哪几类</h4><p>SQL语句的五种分类分别是DQL、DML、DDL、TCL和TCL，下面对SQL语句的五种分类进行列举：</p><ol><li><p>数据库查询语言（DQL）</p><ul><li>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE 子句组成的查询块，简称DQL，Data Query Language。代表关键字为select。</li></ul></li><li><p>数据库操作语言（DML）</p><ul><li>用户通过它可以实现对数据库的基本操作。简称DML，Data Manipulation Language。代表关键字为insert、delete 、update。</li></ul></li><li><p>数据库定义语言（DDL）</p><ul><li>数据定义语言DDL用来创建数据库中的各种对象，创建、删除、修改表的结构，比如表、视图、索引、同义词、聚簇等，简称DDL，Data Denifition Language。代表关键字为create、drop、alter。和DML相比，DML是修改数据库表中的数据，而 DDL 是修改数据中表的结构。</li></ul></li><li><p>事务控制语言（TCL）</p><ul><li>TCL经常被用于快速原型开发、脚本编程、GUI和测试等方面，简称：TCL，Trasactional Control Languag。代表关键字为commit、rollback。</li></ul></li><li><p>数据控制语言（DCL）</p><ul><li>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。简称：DCL，Data Control Language。代表关键字为grant、revoke。</li></ul></li></ol><p>以上就是对SQL语句五种分类的简单介绍，这里针对零基础的初学者只涉及了简单的概念和代表关键字的知识，在了解了这些内容后，再学习更深入的知识（比如SQL优化），希望大家在以后的java培训课程中学习到更多使用和操作方面的技能。</p><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>死锁是指两个或两个以上的进程在执行过程中,由于竞争资源或者由于彼此通信而造成的一种阻塞的现象,若无外力作用,它们都将无法推进下去</p><p>产生原因：</p><ul><li>系统资源不足；</li><li>进程推进顺序非法。</li></ul><p>产生死锁的四个必要条件：</p><ol><li>互斥条件：涉及的资源是非共享的。</li><li>不剥夺条件：进程所获得的资源在未使用完毕之前不能被其它进程强行夺走。</li><li>部分分配：进程每次申请它所需要的一部分资源，在等待新资源的同时继续占用已分配到的资源。</li><li>环路条件：存在着一种进程的循环链，链中的每一个进程已获得的资源同时被链中的下一个进程请求。</li></ol><h4 id="什么是脏读、幻读、不可重复读"><a href="#什么是脏读、幻读、不可重复读" class="headerlink" title="什么是脏读、幻读、不可重复读"></a>什么是脏读、幻读、不可重复读</h4><p><strong>脏读</strong>：某个事物更新了一份数据，另一个事务在此时读取了同一份数据，由于某些原因，RollBack了操作，</p><p>则后一个事务读取的数据就会不正确。</p><p><strong>不可重复读</strong>：在一个事务中两次查询数据不一致，可能两次数据查询过程中插入了一个事务更新原有的数据</p><p>幻读：在一个事务中两次查询数据笔数不一样，如：一个事务查询了几列（row）数据，而另一个事务在此时，插入了几条数据，先前的事务在接下来的查询中，就会发现几列数据是它先前所没有的。</p><h4 id="视图有哪些特点"><a href="#视图有哪些特点" class="headerlink" title="视图有哪些特点"></a>视图有哪些特点</h4><ol><li>简单性</li><li>安全性</li><li>逻辑数据独立性</li></ol><h4 id="MYSQL常用的备份工具有哪些"><a href="#MYSQL常用的备份工具有哪些" class="headerlink" title="MYSQL常用的备份工具有哪些"></a>MYSQL常用的备份工具有哪些</h4><p>逻辑备份（mysqldumo，mydumper）</p><p>物理备份（copy、xtrabackup）</p><h4 id="Mysql的存储引擎-myisam和innodb的区别"><a href="#Mysql的存储引擎-myisam和innodb的区别" class="headerlink" title="Mysql的存储引擎,myisam和innodb的区别"></a>Mysql的存储引擎,myisam和innodb的区别</h4><ol><li>MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持；</li><li>MyISAM类型的表强调的是性能，其执行速度比InnoDB类型更快；</li><li>nnoDB不支持FULLTEXT类型的索引；</li><li>InnoDB中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可；</li><li>对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引；</li><li>DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除；</li><li>LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用；</li><li>MyISAM支持表锁，InnoDB支持行锁。</li></ol><p>MyISAM：成熟、稳定、易于管理，快速读取。一些功能不支持（事务等），表级锁。<br>InnoDB：支持事务、外键等特性、数据行锁定。空间占用大，不支持全文索引等。</p><h4 id="MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年-怎么优化"><a href="#MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年-怎么优化" class="headerlink" title="MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化"></a>MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化</h4><ol><li>设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率；</li><li>选择合适的表字段数据类型和存储引擎，适当的添加索引；</li><li>mysql库主从读写分离；</li><li>找规律分表，减少单表中的数据量提高查询速度；</li><li>添加缓存机制，比如memcached，redis等；</li><li>不经常改动的页面，生成静态页面；</li><li>书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE。</li></ol><h4 id="说说对SQL语句优化有哪些方法-选择几条"><a href="#说说对SQL语句优化有哪些方法-选择几条" class="headerlink" title="说说对SQL语句优化有哪些方法 (选择几条)"></a>说说对SQL语句优化有哪些方法 (选择几条)</h4><ol><li>Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。</li><li>用EXISTS替代IN、用NOT EXISTS替代NOT IN。</li><li>避免在索引列上使用计算</li><li>避免在索引列上使用IS NULL和IS NOT NULL</li><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</li><li>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>PHP</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NodeJS-笔记</title>
    <link href="/2022/05/20/NodeJS-%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/20/NodeJS-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>  <strong>Node.js is a platform built on Chrome’s JavaScript runtime for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I&#x2F;O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.</strong></p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h5><ol><li>它是一个Javascript运行环境</li><li>依赖于Chrome V8引擎进行代码解释</li><li>事件驱动</li><li>非阻塞I&#x2F;O</li><li>轻量、可伸缩，适于实时数据交互应用</li><li>单进程，单线程</li></ol><h3 id="1-简述NodeJS的优势"><a href="#1-简述NodeJS的优势" class="headerlink" title="1. 简述NodeJS的优势"></a>1. 简述NodeJS的优势</h3><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li><p>高并发（最重要的优点）</p></li><li><p>适合I&#x2F;O密集型应用</p></li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>不适合CPU密集型应用；CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I&#x2F;O无法发起；<ul><li>解决方案：<ol><li>分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I&#x2F;O调用的发起；</li></ol></li></ul></li><li>只支持单核CPU，不能充分利用CPU</li><li>可靠性低，一旦代码某个环节崩溃，整个系统都崩溃<ul><li>原因：<strong>单进程</strong>，<strong>单线程</strong></li><li>解决方案：<ol><li>Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；</li><li>开多个进程监听同一个端口，使用cluster模块；</li></ol></li></ul></li><li>开源组件库质量参差不齐，更新快，向下不兼容</li><li>Debug不方便，错误没有stack trace</li></ol><h3 id="2-简述事件驱动编程"><a href="#2-简述事件驱动编程" class="headerlink" title="2.简述事件驱动编程"></a>2.简述事件驱动编程</h3><blockquote><p><a href="http://nodejs.cn/">Node</a>.js使用大量事件，这也是为什么Node.js相对于其他类似技术比较快的原因之一。当Node启动其服务器，就可以简单地初始化其变量，声明函数，然后等待事件的发生。</p></blockquote><blockquote><p>虽然事件似乎类似于<a href="https://so.csdn.net/so/search?q=%E5%9B%9E%E8%B0%83&spm=1001.2101.3001.7020">回调</a>。不同之处在于当回调函数被调用异步函数返回结果，其中的事件处理工作在观察者模式。监听事件函数作为观察者。每当一个事件被解雇，其监听函数开始执行。Node.js有多个内置的事件。 主要扮演者是『EventEmitter』</p></blockquote><h3 id="3-什么是回调函数"><a href="#3-什么是回调函数" class="headerlink" title="3.什么是回调函数"></a>3.什么是回调函数</h3><blockquote><p>Node.js 异步编程的直接体现就是回调。</p><p>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。</p><p>回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。</p></blockquote><p>总结：<strong>一个函数中调用另外一个函数就是回调『callback』</strong></p><h3 id="4-简述NodeJS中事件循环"><a href="#4-简述NodeJS中事件循环" class="headerlink" title="4.简述NodeJS中事件循环"></a>4.简述NodeJS中事件循环</h3><blockquote><p>Node.js 在主线程里维护了一个<strong>事件队列，</strong>当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 I&#x2F;O 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 I&#x2F;O 任务，就从 <strong>线程池</strong> 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。</p><p>当线程中的 I&#x2F;O 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 <strong>事件循环</strong> (Event Loop)，</p></blockquote><p>总结：<strong>在非I&#x2F;O任务的情况下，一个事件完成后并将它放到事件的尾部，等待事件循环，当主线程再次循环到他时将继续完成事件。这个过程就叫做事件循环『Event Loop』</strong></p>]]></content>
    
    
    <categories>
      
      <category>NodeJS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>NODEJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP-笔记</title>
    <link href="/2022/05/18/PHP-%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/18/PHP-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1-PHP-中传值与传引用的区别，什么时候传值-什么时候传引用"><a href="#1-PHP-中传值与传引用的区别，什么时候传值-什么时候传引用" class="headerlink" title="1. PHP 中传值与传引用的区别，什么时候传值,什么时候传引用"></a>1. PHP 中传值与传引用的区别，什么时候传值,什么时候传引用</h3><h5 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h5><ul><li>将实参的值赋值给行参那么对行参的修改，不会影响实参的值。</li></ul><h5 id="传地址"><a href="#传地址" class="headerlink" title="传地址"></a>传地址</h5><ul><li>是传值的一种特殊方式，只是他传递的是地址，不是普通的如int，那么传地址以后，实参和行参都指向同一个对象。</li></ul><h5 id="传引用"><a href="#传引用" class="headerlink" title="传引用"></a>传引用</h5><ul><li>真正的以地址的方式传递参数传递以后，行参和实参都是同一个对象，只是他们名字不同而已对行参的修改将影响实参的值。</li></ul><h5 id="传值与传引用的使用场景"><a href="#传值与传引用的使用场景" class="headerlink" title="传值与传引用的使用场景"></a>传值与传引用的使用场景</h5><ul><li>按<strong>值传递</strong>：函数范围内对值的任何改变在函数外部都会被忽略。</li><li>按<strong>引用传递</strong>：函数范围内对值的任何改变在函数外部也能反映出这些修改。<ol><li>优缺点：按值传递时，php必须复制值。特别是对于大型的<strong>字符串</strong>和<strong>对象</strong>来说，这将会是一个代价很大的操作。</li><li>按引用传递则不需要复制值，对于性能提高很有好处。</li></ol></li></ul><h3 id="2-SESSION-与-COOKIE的区别是什么"><a href="#2-SESSION-与-COOKIE的区别是什么" class="headerlink" title="2. SESSION 与 COOKIE的区别是什么"></a>2. SESSION 与 COOKIE的区别是什么</h3><h5 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a><strong>什么是 Cookie</strong></h5><blockquote><p>HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p></blockquote><p><strong>Cookie 主要用于以下三个方面</strong>：</p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h5 id="什么是-Session"><a href="#什么是-Session" class="headerlink" title="什么是 Session"></a><strong>什么是 Session</strong></h5><blockquote><p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p></blockquote><h5 id="Cookie-和-Session-有什么不同"><a href="#Cookie-和-Session-有什么不同" class="headerlink" title="Cookie 和 Session 有什么不同"></a>Cookie 和 Session 有什么不同</h5><ul><li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li><li>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li><li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li><li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li><li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li></ul><h3 id="3-表单中get和post提交方式的区别"><a href="#3-表单中get和post提交方式的区别" class="headerlink" title="3. 表单中get和post提交方式的区别"></a>3. 表单中get和post提交方式的区别</h3><h5 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h5><ol><li>Get是用来从服务器上获得数据，而Post是用来向服务器上传递数据。</li><li>Get将表单中数据的按照variable&#x3D;value的形式，添加到action所指向的URL后面，并且两者使用“?”连接，而各个变量之间使用“&amp;”连接；Post是将表单中的数据放在form的数据体中，按照变量和值相对应的方式，传递到action所指向URL。</li><li>Get是不安全的，因为在传输过程，数据被放在请求的URL中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求URL记录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一同显示在用户面前。Post的所有操作对用户来说都是不可见的。</li><li>Get传输的数据量小，这主要是因为受URL长度限制；而Post可以传输大量的数据，所以在上传文件只能使用Post（当然还有一个原因，将在后面的提到）。</li><li>Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。</li><li>Get是Form的默认方法。</li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>Get 方式传输的数据量非常小，一般限制在 2 KB 左右，但是执行效率却比 Post 方法好；而 Post 方式传递的数据量相对较大，它是等待服务器来读取数据，不过也有字节限制，这是为了避免对服务器用大量数据进行恶意攻击，根据微软方面的说法，微软对用 Request.Form() 可接收的最大数据有限制，IIS 4 中为 80 KB 字节，IIS 5 中为 100 KB 字节。</li><li>Get 方式提交数据，会带来安全问题，比如一个登陆页面，通过 Get 方式提交数据时，用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问客户这台机器，就可以从历史记录获得该用户的帐号和密码，所以表单提交建议使用 Post 方法；Post 方法提交的表单页面常见的问题是，该页面如果刷新的时候，会弹出一个对话框</li></ul><p><strong>建议出于安全性考虑，建议最好使用 Post 提交数据</strong></p><h3 id="4-简述PHP中-isset、empty、is-null的区别"><a href="#4-简述PHP中-isset、empty、is-null的区别" class="headerlink" title="4 .简述PHP中 isset、empty、is_null的区别"></a>4 .简述PHP中 isset、empty、is_null的区别</h3><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><ul><li>isset 判断变量是否已存在（配置）</li><li>unset 把变量删除（释放）掉</li><li>empty 判断变量是否为空</li><li>is_null 判断变量是否为NULL</li></ul><h5 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h5><table><thead><tr><th>变量</th><th>empty</th><th>is_null</th><th>isset</th></tr></thead><tbody><tr><td>$a &#x3D; “”</td><td>true</td><td>false</td><td>true</td></tr><tr><td>$a&#x3D;null</td><td>true</td><td>true</td><td>false</td></tr><tr><td>var $a</td><td>true</td><td>true</td><td>false</td></tr><tr><td>$a &#x3D; arrary()</td><td>true</td><td>false</td><td>true</td></tr><tr><td>$a &#x3D; false</td><td>true</td><td>false</td><td>true</td></tr><tr><td>$a &#x3D; 15</td><td>false</td><td>false</td><td>true</td></tr><tr><td>$a &#x3D; 1</td><td>false</td><td>false</td><td>true</td></tr><tr><td>$a &#x3D; 0</td><td>true</td><td>false</td><td>true</td></tr><tr><td>$a &#x3D; “0”</td><td>true</td><td>false</td><td>true</td></tr><tr><td>$a &#x3D; “true”</td><td>false</td><td>false</td><td>true</td></tr><tr><td>$a &#x3D; “false”</td><td>false</td><td>false</td><td>true</td></tr></tbody></table><h3 id="5-简述PHP中单引号双引号的区别"><a href="#5-简述PHP中单引号双引号的区别" class="headerlink" title="5.简述PHP中单引号双引号的区别"></a>5.简述PHP中单引号双引号的区别</h3><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p> 双引号串中的内容可以被解释而且替换，而单引号串中的内容总被认为是普通字符。</p><p> 例如：</p><figure class="highlight php"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$foo</span> = <span class="hljs-number">2</span>; <br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;foo is <span class="hljs-subst">$foo</span>&quot;</span>; <br><br><span class="hljs-comment">// 打印结果: foo is 2 </span><br><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;foo is $foo&#x27;</span>; <br><br><span class="hljs-comment">// 打印结果: foo is $foo </span><br></code></pre></td></tr></table></figure><p><strong>php中单引号和双引号的区别，哪个速度更快？为什么？</strong></p><ul><li><p><strong>答：单引号更快。</strong></p><ul><li><p>在php中，单引号内的数据不会被解析(任何变量和特殊转义字符)，所以速度更快，而双引号内的数据会被解析，如变量($var)值会代入字符串中，特殊转义字符也会被解析成特定的单个字。</p></li><li><p>数组中，如果下标不是整型，而是字符串类型。</p></li></ul></li></ul><h3 id="6-简述PHP-OOP的三大特性"><a href="#6-简述PHP-OOP的三大特性" class="headerlink" title="6.简述PHP OOP的三大特性"></a>6.简述PHP OOP的三大特性</h3><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><ul><li>简单形象的解释就是，把功能放在一个盒子里，要用到这个功能的时候，打开盒子，取出就可以使用。<ol><li>封装是指把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行<strong>信息隐藏</strong>。</li><li>简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</li></ol></li></ul><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ul><li><p>子类自动继承一个或多个父类中的属性与方法，并可以重写或者添加新的属性或方法。（这个特性简化了<strong>类和对象</strong>的创建，提高了代码的可重用性。）</p><ol><li>继承是指可以让某个类型的对象获得另一个类型的对象的属性的方法,它支持按级分类的概念。</li><li>它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</li></ol></li></ul><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><ul><li>指的是一个类可以创建多个对象，获取不同的结果。<ol><li>多态就是指一个类实例的相同方法在不同情形有不同表现形式。</li><li>多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</li></ol></li></ul><h3 id="7-简述MVC的优缺点"><a href="#7-简述MVC的优缺点" class="headerlink" title="7.简述MVC的优缺点"></a>7.简述MVC的优缺点</h3><h5 id="MVC原理"><a href="#MVC原理" class="headerlink" title="MVC原理"></a>MVC原理</h5><blockquote><p><strong>MVC 是一种程序开发设计模式,它实现了显示模块与功能模块的分离。提高了程序的可维护性、可移植性、可扩展性与可重用性，降低了程序的开发难度。它主要分模型、视图、控制器三层</strong></p></blockquote><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li>可定制性：可以为一个模型在运行时同时建立和使用多个视图。变化-传播机制可以确保所有相关的视图及时得到模型数据变化，从而使所有关联的视图和控制器做到行为同步。</li><li>代码清晰，便于维护：模型的可移植性。因为模型是独立于视图的，所以可以把一个模型独立地移植到新的平台工作。需要做的只是在新平台上对视图和控制器进行新的修改</li><li>视图与控制器的可接插性，允许更换视图和控制器对象，而且可以根据需求动态的打开或关闭、甚至在运行期间进行对象替换。</li><li>潜在的框架结构。可以基于此模型建立应用程序框架，不仅仅是用在设计界面的设计中</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>增加了系统结构和实现的复杂性：增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</li><li>视图跟控制器过于紧密的连接：视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用</li><li>视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</li><li>目前，一般高级的界面工具或构造器不支持模式。改造这些工具以适应MVC需要和建立分离的部件的代价是很高的，从而造成MVC使用的困难。<ul><li><strong>使用mvc，会增加代码量、相应地也会增加软件开发的成文，设计的难度也会增加。</strong></li></ul></li></ol><h3 id="8-如何理解单一入口文件？"><a href="#8-如何理解单一入口文件？" class="headerlink" title="8.如何理解单一入口文件？"></a>8.如何理解单一入口文件？</h3><h5 id="了解区分单入口及多入口"><a href="#了解区分单入口及多入口" class="headerlink" title="了解区分单入口及多入口"></a>了解区分单入口及多入口</h5><p>在解释什么是单一入口之前，先说说与之对应的多入口。多入口即通过访问不同的 php 文件运行对应的功能。比如刚开始学习 php 的时候，我们做一个项目通常都会如下这样做：</p><blockquote><p>index.php - 网站首页</p></blockquote><blockquote><p>list.php?page&#x3D;5 - 内容列表页</p></blockquote><blockquote><p>info.php?id&#x3D;12 - 内容详细页</p></blockquote><blockquote><p>login.php - 用户登录页</p></blockquote><p>对于这个项目来说，这其实就是一个多入口。</p><p>那么单一入口的应用程序就是说用一个文件处理所有的HTTP请求，例如不管是内容列表页，用户登录页还是内容详细页，都是通过从浏览器访问 index.php 文件来进行处理的，这里这个 index.php 文件就是这个应用程序的单一入口。</p><h3 id="9-简述中间件的优缺点"><a href="#9-简述中间件的优缺点" class="headerlink" title="9.简述中间件的优缺点"></a>9.简述中间件的优缺点</h3><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><ul><li>复杂系统的<strong>解耦</strong></li><li>复杂链路的<strong>异步</strong>调用</li><li>瞬时高峰的<strong>削峰</strong>处理</li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>系统可用性降低</li><li>系统稳定性降低 || 系统复杂度提高<ul><li>网络故障- -消息丢失；</li><li>消息重复- -脏数据的产生；</li><li>宕机，无法消费消息- -消息积压</li></ul></li><li>分布式一致性问题</li></ul><p><a href="https://www.jianshu.com/p/eaafb1581e55">中间件-消息队列的优缺点，区别</a> [简书]</p><p><a href="https://blog.csdn.net/eluanshi12/article/details/85275044">消息中间件- -优缺点及使用</a> [CSDN]</p><h3 id="10-简述restful-api接口规范"><a href="#10-简述restful-api接口规范" class="headerlink" title="10.简述restful api接口规范"></a>10.简述restful api接口规范</h3><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>REST：英文representational state transfer直译为表现层状态转移，或者表述性状态转移；Rest是web服务的一种架构风格，一种设计风格，是一种思想；同时Rest不是针对某一种编程语言的。</p><p>以<a href="http://www.360doc.com/content/21/1103/23/75593589_1002656623.shtml">WebService</a>为例通俗解释。</p><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>非Rest设计，以往我们都会这么写：</p><blockquote><p><a href="http://localhost:8080/admin/getUser">http://localhost:8080/admin/getUser</a> （查询用户）</p></blockquote><blockquote><p><a href="http://localhost:8080/admin/addUser">http://localhost:8080/admin/addUser</a> （新增用户）</p></blockquote><blockquote><p><a href="http://localhost:8080/admin/updateUser">http://localhost:8080/admin/updateUser</a> （更新用户）</p></blockquote><blockquote><p><a href="http://localhost:8080/admin/deleteUser">http://localhost:8080/admin/deleteUser</a>  （删除用户）</p></blockquote><p>总结：<strong>以不同的URL（主要为使用动词）进行不同的操作。</strong></p><p>Rest架构：</p><blockquote><p>GET <a href="http://localhost:8080/admin/user">http://localhost:8080/admin/user</a> （查询用户）</p></blockquote><blockquote><p>POST <a href="http://localhost:8080/admin/user">http://localhost:8080/admin/user</a> （新增用户）</p></blockquote><blockquote><p>PUT <a href="http://localhost:8080/admin/user">http://localhost:8080/admin/user</a> （更新用户）</p></blockquote><blockquote><p>DELETE <a href="http://localhost:8080/admin/user">http://localhost:8080/admin/user</a> （删除用户）</p></blockquote><p>总结：<u><strong>URL只指定资源，以HTTP方法动词进行不同的操作。用HTTP STATUS&#x2F;CODE定义操作结果。</strong></u></p><p><u><strong>Restful：遵守了rest风格的web服务便可称为Restful。</strong></u></p><p><a href="https://www.jianshu.com/p/a6d9cf64e954">Restful API接口规范</a> [简书]</p><h3 id="11-简述容器、依赖注入的原理"><a href="#11-简述容器、依赖注入的原理" class="headerlink" title="11.简述容器、依赖注入的原理"></a>11.简述容器、依赖注入的原理</h3><ol><li>任何的URL访问，最终都是定位到控制器，由控制器中的某个具体的方法去执行。</li><li>一个控制器对应着一个类，如果这些类需要进行统一的管理，怎么办？ <ol><li><strong>容器</strong>:容器来进行管理（但是容器并不管理控制器类，因为控制器类是用户直接访问的），还可以将类的实例作为参数，传递给类方法，自动触发依赖注入。</li><li>依赖注入:将对象类型的数据，以参数的方式传到方法的参数列表中。</li><li>URL访问:通过GET方式将数据传到控制器指定的方法中，但是只能传字符串，数值。</li></ol></li><li>如果要传一个对象到当前方法中？怎么办？<ol><li><strong>依赖注入</strong>:解决了向类中的方法传对象的问题</li></ol></li></ol><p><a href="https://cloud.tencent.com/developer/article/1734158">PHP进阶学习之依赖注入与Ioc容器详解</a> [腾讯云]</p><p><a href="https://zhuanlan.zhihu.com/p/99709637">PHP依赖注入原理与用法分析</a> [知乎]</p><p><a href="https://www.kancloud.cn/cherals/tp51/1003213">容器与依赖注入的原理</a> [ThinkPHP5.1官方文档]</p><h3 id="12-PHP中语句include和require的区别是什么？"><a href="#12-PHP中语句include和require的区别是什么？" class="headerlink" title="12.PHP中语句include和require的区别是什么？"></a>12.PHP中语句include和require的区别是什么？</h3><h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><ul><li>require() 语句的性能与 include() 相类似，都是包括并运行指定文件。</li><li>不同之处在于：<ul><li>对 include() 语句来说，在执行文件时每次都要进行读取和评估；</li><li>而对于 require() 来说，文件只处理一次（实际上，文件内容替换 require() 语句）。这就意味着如果可能执行多次的代码，则使用 require() 效率比较高。</li></ul></li><li>另外一方面，如果每次执行代码时是读取不同的文件，或者有通过一组文件迭代的循环，就使用 include() 语句。</li></ul><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ul><li><strong>incluce</strong> 在用到时加载<ul><li>include 通常用在流程控制的处理部分中，php 脚本在读到 include 的文件时，才将它读进来。这种方式，可以把程序执行时的流程简单化。</li></ul></li><li><strong>require</strong> 在一开始就加载<ul><li>require通常放在php脚本程序最前面，php再执行程序前，就会先读取require语句引入的文件，使之成为php脚本文件的一部分。</li></ul></li><li><strong>_once</strong> 后缀表示已加载的不加载</li></ul><hr><p><strong><a href="https://www.kancloud.cn/chunyu/php_basic_knowledge/767166">PHP知识总结 </a></strong> [看云笔记]</p>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql-笔记</title>
    <link href="/2022/05/15/Mysql-%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/15/Mysql-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1-主键和外键的区别"><a href="#1-主键和外键的区别" class="headerlink" title="1.主键和外键的区别"></a>1.主键和外键的区别</h3><h5 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h5><ul><li>可以是表的任何字段或列，对于每条记录或一行，主键应是唯一的非空值。</li></ul><h5 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h5><ul><li>是一个字段，其中包含用于在彼此之间建立连接的其他表的主键。</li></ul><h5 id="主键及外键的用途"><a href="#主键及外键的用途" class="headerlink" title="主键及外键的用途"></a>主键及外键的用途</h5><ol><li>主键是能确定一条记录的唯一标识，比如，一条记录包括身份正号，姓名，年龄。身份证号是唯一能确定你这个人的，其他都可能有重复，所以，身份证号是主键。</li><li>外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。<ul><li>比如，A表中的一个字段，是B表的主键，那他就可以是A表的外键。</li></ul></li></ol><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul><li>主键是唯一标识一条记录，不能重复，不允许为空；而外键可以重复，可以是空值；</li><li>主键是用来保持数据完整性，外键是用来建立与其他表联系用的；</li><li>主键只有一个，外键可以有多个。</li></ul><h3 id="2-MYSQL-的内连接、左连接、右连接有什么区别"><a href="#2-MYSQL-的内连接、左连接、右连接有什么区别" class="headerlink" title="2.MYSQL 的内连接、左连接、右连接有什么区别"></a>2.MYSQL 的内连接、左连接、右连接有什么区别</h3><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><ul><li>系统会自动忽略两个表中对应不起来的数据，只显示两个表中关联的数据</li></ul><h5 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h5><ul><li>一左边的表为基准，将左边的数据全部显示出来，右表中没有对应的数据用null补齐，数据多了不显示</li></ul><h5 id="右连接"><a href="#右连接" class="headerlink" title="右连接"></a>右连接</h5><ul><li>以右表为准，将右表的数据全部显示出来，左表中没有相对应的数据用null补齐，数据多了不显示</li></ul><h3 id="3-说一下数据库的三大范式"><a href="#3-说一下数据库的三大范式" class="headerlink" title="3.说一下数据库的三大范式"></a>3.说一下数据库的三大范式</h3><h5 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h5><ul><li><strong>确保每列保持原子性</strong></li></ul><h5 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h5><ul><li><strong>确保表中的每列都和主键相关</strong></li></ul><h5 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h5><ul><li><strong>确保每列都和主键列直接相关,而不是间接相关</strong></li></ul><blockquote><p><a href="https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html">数据库设计三大范式</a>   [作者:Ruthless]</p></blockquote><h3 id="4-MYSQL-约束有哪几种"><a href="#4-MYSQL-约束有哪几种" class="headerlink" title="4.MYSQL 约束有哪几种"></a>4.MYSQL 约束有哪几种</h3><blockquote><ol><li><strong>非空约束“not null”</strong></li><li><strong>唯一性约束“unique”</strong></li><li><strong>主键约束“primary key”</strong></li><li><strong>外键约束“foreign key”</strong></li><li><strong>默认值约束“Default”</strong></li></ol></blockquote><h3 id="5-什么是数据库事务"><a href="#5-什么是数据库事务" class="headerlink" title="5.什么是数据库事务"></a>5.什么是数据库事务</h3><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><ol><li>数据库事务是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。</li><li>关于事务的定义有几点需要解释下：<ul><li>1.数据库事务可以包含一个或多个数据库操作,但这些操作构成一个逻辑上的整体。</li><li>2.构成逻辑整体的这些数据库操作,要么全部执行成功,要么全部不执行。</li><li>3.构成事务的所有操作,要么全都对数据库产生影响,要么全都不产生影响,即不管事务是否执行成功,数据库总能保持一致性状态。</li><li>4.以上即使在数据库出现故障以及并发事务存在的情况下依然成立。</li></ul></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><strong>事务是数据库系统进行并发控制的基本单位,是数据库系统进行故障恢复的基本单位,从而也是保持数据库状态一致性的基本单位。ACID是事务的基本特性,数据库系统是通过并发控制技术和日志恢复技术来对事务的ACID进行保证的,从而可以得到如下的关于数据库事务的概念体系结构。</strong></p><h3 id="6-分别简述MYSQL中MyISAM和InnoDB存储引擎的使用场景"><a href="#6-分别简述MYSQL中MyISAM和InnoDB存储引擎的使用场景" class="headerlink" title="6.分别简述MYSQL中MyISAM和InnoDB存储引擎的使用场景"></a>6.分别简述MYSQL中MyISAM和InnoDB存储引擎的使用场景</h3><blockquote><p>原文链接：<a href="https://blog.csdn.net/m0_37814112/article/details/78633136">MyISAM引擎和InnoDB引擎介绍及应用场景</a>  [作者:东城绝神]</p></blockquote><h5 id="MyISAM引擎"><a href="#MyISAM引擎" class="headerlink" title="MyISAM引擎"></a>MyISAM引擎</h5><h6 id="什么是MyISAM引擎"><a href="#什么是MyISAM引擎" class="headerlink" title="什么是MyISAM引擎"></a>什么是MyISAM引擎</h6><blockquote><p>MyISAM引擎是MySQL关系数据库管理系统的默认存储引擎（MySQL5.5版本以前）。这种MySQL</p><p>表存储结构从旧的ISAM代码扩展出许多有用的功能。在新版本的MySQL中，InnoDB引擎由于其对事物参照完整性，以及更高的并发性等优点开始逐步的取代MyISAM引擎。</p><p>小结：事物参照完整性可理解为数据的一致性。</p></blockquote><h6 id="MyISAM引擎的特点"><a href="#MyISAM引擎的特点" class="headerlink" title="MyISAM引擎的特点"></a>MyISAM引擎的特点</h6><ol><li><p>不支持事务（事务就是逻辑上的一组SQL语句操作，组成这组操作的各个SQL语句，执行时要么全部成功，要么全部失败）</p></li><li><p>表级锁定（更新是锁整个表）：其锁定机制是表级锁定，虽然可以让锁定的实现成本很小，但是大大的降低了其并发性能。<strong>小结：MyISAM锁定的范围太大</strong></p></li><li><p>读写互相堵塞：不仅会在写入的时候阻塞读取，MyISAM还会在读取的时候阻塞写入，但读本身并不会阻塞另外的读。</p></li><li><p>只会缓存索引：MyISAM可以通过key_buffer_size缓存索引，大大提高访问性能，减少磁盘的I&#x2F;O，但是缓存区只会缓存索引，不会缓存数据。</p></li><li><p>读取速度较快，占用资源相对少。</p></li><li><p>不支持外键约束，但支持全文索引。</p></li><li><p>MyISQM引擎是mysql_5.5.5之前的索引。</p></li></ol><h6 id="MyISAM引擎使用的生产业务场景"><a href="#MyISAM引擎使用的生产业务场景" class="headerlink" title="MyISAM引擎使用的生产业务场景"></a>MyISAM引擎使用的生产业务场景</h6><ol><li><p>不需要事务支持的业务（转账、充值、付款这种就不行）。</p></li><li><p>一般为读数据比较多的应用。读写都频繁的不适合，读多或写多都适合。</p></li><li><p>并发访问相对低的业务（纯读、纯写高并发也可以）。</p></li><li><p>数据修改相对较少的业务（阻塞问题）。</p></li><li><p>以读为主的业务，例如：www，blog，图片信息数据库，用户数据库，商品库等业务。</p></li><li><p>对数据一致性要求不是很高的业务。</p></li><li><p>硬件资源比较差的机器可以用MyISAM。</p></li><li></li></ol><p><strong>小结：单一对数据库的操作都可以使用MyISAM引擎。</strong></p><h5 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h5><h6 id="什么是InnoDB引擎"><a href="#什么是InnoDB引擎" class="headerlink" title="什么是InnoDB引擎"></a>什么是InnoDB引擎</h6><blockquote><p>InnoDB引擎是MySQL数据库的另一个重要的存储引擎，正成为目前MySQL所发行新版本的标准，被包含在所有二进制安装包里。和其它的存储引擎相比，InnoDB引擎的优点是支持兼容ACID的事务（类似于PostgreSQL）,以及参数的完整性（即对外键的支持）。</p><p>mysql&gt; select version();</p><p>+———–+</p><p>| version() |</p><p>+———–+</p><p>| 5.6.17    |</p><p>+———–+</p><p>1 row in set (0.00 sec)</p></blockquote><h6 id="InnoDB引擎特点"><a href="#InnoDB引擎特点" class="headerlink" title="InnoDB引擎特点"></a>InnoDB引擎特点</h6><ol><li><p>支持事务：支持事务的四个级别（ACID）。</p></li><li><p>行级锁定：通过索引实现，全表扫描仍然是表锁。</p></li><li><p>读写阻塞与事务隔离级别相关。</p></li><li><p>具有非常高效的缓存特性：能缓存索引，也能缓存数据。</p></li><li><p>整个表和主键以cluster方式存储，组成一颗平衡树。</p></li><li><p>所有secondary inex都会保存主键信息。</p></li><li><p>支持分区，表空间，类似oracle数据库。</p></li><li><p>支持外键约束，不支持全文索引。5.5版本以前不支持全文索引，5.5版本之后支持。</p></li><li><p>和MyISAM相比对硬件的资源要求比较高。</p></li></ol><h6 id="InnoDB引擎使用的生产业务场景"><a href="#InnoDB引擎使用的生产业务场景" class="headerlink" title="InnoDB引擎使用的生产业务场景"></a>InnoDB引擎使用的生产业务场景</h6><ol><li><p>需要事务支持的业务（具有较好的事务特性）。</p></li><li><p>行级锁定对高并发有很好的适用能力，但需要确保查询是通过索引来来完成的。</p></li><li><p>数据读写及更新都较为频繁的场景,如：BBS、SNS、微博等。</p></li><li><p>数据一致性要求较高的业务，如：充值转账。</p></li><li><p>硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存使用率，尽可能的较少磁盘的I&#x2F;O。</p></li></ol><h3 id="7-简述视图的优点、缺点"><a href="#7-简述视图的优点、缺点" class="headerlink" title="7.简述视图的优点、缺点"></a>7.简述视图的优点、缺点</h3><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li><strong>简单性</strong><ul><li>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使用户不必为以后的操作每次都指定全部的条件。</li></ul></li><li><strong>安全性</strong><ul><li>通过视图用户只能查询和修改他们所能见到的数据。数据库中的其他数据则既看不见也取不到。数据库授权命令可以使每个用户对数据库的检索限制到特定的数据库对象上，但不能授权到数据库特定行和特定的列上。通过视图，用户可以被限制在数据的不同子集上。</li></ul></li><li><strong>逻辑数据独立性</strong><ul><li>视图可以使应用程序和数据库表在一定程度上独立。如果没有视图，应用一定是建立在表上的。有了视图之后，程序可以建立在视图之上，从而程序与数据库表被视图分割开来。</li></ul></li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li><strong>性能</strong> <ul><li>数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，SQL Server也把它变成一个复杂的结合体，需要花费一定的时间。</li></ul></li><li><strong>修改限制</strong> <ul><li>当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的。</li></ul></li></ul><h3 id="8-简述索引的优点、缺点"><a href="#8-简述索引的优点、缺点" class="headerlink" title="8.简述索引的优点、缺点"></a>8.简述索引的优点、缺点</h3><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ol><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 </li><li>可以大大加快 数据的检索速度，这也是创建索引的最主要的原因。 </li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ol><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ol><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ol><h5 id="什么样的字段下适合创建索引"><a href="#什么样的字段下适合创建索引" class="headerlink" title="什么样的字段下适合创建索引"></a>什么样的字段下适合创建索引</h5><ul><li>在经常需要搜索的列上，可以加快搜索的速度</li><li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构</li><li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度</li><li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的</li><li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间</li><li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li></ul><h3 id="9-什么是存储过程？有哪些优缺点？"><a href="#9-什么是存储过程？有哪些优缺点？" class="headerlink" title="9.什么是存储过程？有哪些优缺点？"></a>9.什么是存储过程？有哪些优缺点？</h3><ul><li><strong>存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块， 这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这 个代码块取一个名字，在用到这个功能的时候调用他就行了。</strong></li><li><strong>存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ， 可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全</strong></li></ul><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><ol><li><strong>减少网络通信量</strong> <ul><li>调用一个行数不多的存储过程与直接调用SQL语句的网络通信量可能不会有很大的差别，可是如果存储过程包含上百行SQL语句，那么其性能绝对比一条一条的调用SQL语句要高得多。</li></ul></li><li><strong>执行速度更快</strong> <ul><li>在存储过程创建的时候，数据库已经对其进行了一次解析和优化。</li><li>存储过程一旦执行，在内存中就会保留一份这个存储过程，这样下次再执行同样的存储过程时，可以从内存中直接调用。</li></ul></li><li><strong>更强的适应性</strong><ul><li>由于存储过程对数据库的访问是通过存储过程来进行的，因此数据库开发人员可以在不改动存储过程接口的情况下对数据库进行任何改动，而这些改动不会对应用程序造成影响。</li></ul></li><li><strong>布式工作</strong><ul><li>应用程序和数据库的编码工作可以分别独立进行，而不会相互压制。</li></ul></li></ol><h3 id="10-MySQL中都有哪些触发器，并简述触发器的优缺点"><a href="#10-MySQL中都有哪些触发器，并简述触发器的优缺点" class="headerlink" title="10.MySQL中都有哪些触发器，并简述触发器的优缺点"></a>10.MySQL中都有哪些触发器，并简述触发器的优缺点</h3><h5 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h5><p>  创建触发器的语法结构是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs mysql">CREATE TRIGGER 触发器名称<br>&#123;BEFORE | AFTER&#125;<br>&#123;INSERT | UPDATE | DELETE &#125; ON 表名 FOR EACH ROW<br>触发器执行的语句块;<br></code></pre></td></tr></table></figure><p>说明：</p><p>①表名 ：表示触发器监控的对象。</p><p>②BEFORE|AFTER ：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。</p><p>③INSERT|UPDATE|DELETE ：表示触发的事件。</p><p>INSERT 表示插入记录；</p><p>UPDATE 表示更新记录；</p><p>DELETE 表示删除记录。</p><p>④触发器执行的语句块 ：可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块。</p><p>举例：</p><p>①创建数据表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test_trigger ( id  INT PRIMARY KEY  AUTO_INCREMENT,    t_note  VARCHAR (30) ); <br> CREATE TABLE test_trigger_log ( id  INT PRIMARY KEY  AUTO_INCREMENT, t_log VARCHAR (30) );<br></code></pre></td></tr></table></figure><p>②创建触发器：创建名称为before_insert的触发器，向test_trigger数据表插入数据之前，向test_trigger_log数据表中插入before_insert的日志信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE TRIGGER before_insert BEFORE INSERT ON test_trigger FOR EACH ROW BEGIN <br>INSERT INTO test_trigger_log (t_log)  VALUES (&#x27;before_insert&#x27;); END<br>// DELIMITER ;<br></code></pre></td></tr></table></figure><p>③向test_trigger数据表中插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO test_trigger (t_note) VALUES (&#x27;测试 BEFORE INSERT 触发器&#x27;);<br></code></pre></td></tr></table></figure><p>④查看test_trigger_log数据表中的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM test_trigger_log;<br>+----+---------------+<br>| id | t_log |<br>+----+---------------+<br>| 1 | before_insert |<br>+----+---------------+<br>1 row in set 0.00 sec)<br></code></pre></td></tr></table></figure><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ol><li>SQL触发器提供了检查数据完整性的替代方法。</li><li>SQL触发器可以捕获数据库层中业务逻辑中的错误。</li><li>SQL触发器提供了<strong>运行计划任务</strong>的另一种方法。通过使用SQL触发器，您不必等待运行计划的任务，因为在对表中的数据进行更改之前或之后自动调用触发器。</li><li>SQL触发器对于审核表中数据的更改非常有用。</li></ol><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ol><li>SQL触发器只能提供扩展验证，并且无法替换所有验证。一些简单的验证必须在应用层完成。 例如，您可以使用JavaScript或服务器端使用服务器端脚本语言(如JPS , PHP , ASP.NET , Perl等)来验证客户端的用户输入。</li><li>从客户端应用程序调用和执行SQL触发器不可见，因此很难弄清数据库层中发生的情况。</li><li>SQL触发器可能会增加数据库服务器的开销。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown-语法</title>
    <link href="/2022/05/11/Markdown-%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/05/11/Markdown-%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、注释"><a href="#一、注释" class="headerlink" title="一、注释"></a>一、注释</h3><h4 id="1、代码法"><a href="#1、代码法" class="headerlink" title="1、代码法"></a>1、代码法</h4><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;display: none&#x27;</span>&gt;</span><br>哈哈我是注释，不会在浏览器中显示。<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2、html注释"><a href="#2、html注释" class="headerlink" title="2、html注释"></a>2、html注释</h4><p>快捷键  [ctrl + &#x2F; ]   || [comment + &#x2F;]</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--哈哈我是注释，不会在浏览器中显示。--&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">哈哈我是多段注释，</span><br><span class="hljs-comment">不会在浏览器中显示。</span><br><span class="hljs-comment">    --&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3、hack方法"><a href="#3、hack方法" class="headerlink" title="3、hack方法"></a>3、hack方法</h4><p>hack方法就是利用markdown的解析原理来实现注释的。<br>一般有的markdown解析器不支持上面的注释方法，这个时候就可以用hack方法。<br>hack方法比上面2种方法稳定得多，但是语义化太差。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-comment">//]: # (哈哈我是最强注释，不会在浏览器中显示。)</span><br>[^_^]: <span class="hljs-meta"># (哈哈我是最萌注释，不会在浏览器中显示。)</span><br>[<span class="hljs-comment">//]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br>[<span class="hljs-meta">comment</span>]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。<br></code></pre></td></tr></table></figure><h3 id="二、标题"><a href="#二、标题" class="headerlink" title="二、标题"></a>二、标题</h3><p>Markdown 标题有两种格式。</p><h4 id="1、使用-x3D-和-标记"><a href="#1、使用-x3D-和-标记" class="headerlink" title="1、使用 &#x3D; 和 - 标记"></a>1、使用 &#x3D; 和 - 标记</h4><p>一级标题和二级标题</p><p>&#x3D; 和 - 标记语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs none">我是一级标题<br>=================<br><br>我是二级标题<br>-----------------<br></code></pre></td></tr></table></figure><h4 id="2、使用-标记"><a href="#2、使用-标记" class="headerlink" title="2、使用 # 标记"></a>2、使用 # 标记</h4><p>使用 <strong>#</strong> 号可表示 1-6 级标题，一级标题对应一个 <strong>#</strong> 号，二级标题对应两个 <strong>#</strong> 号，以此类推。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs none">[ctrl + 1]# 一级标题<br>[ctrl + 2]## 二级标题<br>[ctrl + 3]### 三级标题<br>[ctrl + 4]#### 四级标题<br>[ctrl + 5]##### 五级标题<br>[ctrl + 6]###### 六级标题<br></code></pre></td></tr></table></figure><h3 id="三、缩进、换行、空行、对齐方式"><a href="#三、缩进、换行、空行、对齐方式" class="headerlink" title="三、缩进、换行、空行、对齐方式"></a>三、缩进、换行、空行、对齐方式</h3><ul><li><strong>首行缩进</strong></li></ul><p>不同特殊占位符所占空白是不一样大的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">【1】 &amp;emsp;或&amp;<span class="hljs-comment">#8195; //全角</span><br>【2】 &amp;ensp;或&amp;<span class="hljs-comment">#8194; //半角</span><br>【3】 &amp;nbsp;或&amp;<span class="hljs-comment">#160;  //半角之半角</span><br></code></pre></td></tr></table></figure><ul><li><strong>换行</strong></li></ul><p>由于markdown编辑器的不同,可能在一行字后面，直接换行回车，也能实现换行，但是在Visual Studio Code上，想要<strong>换行必须得在一行字后面空两个格子才行</strong>。</p><ul><li><strong>空行</strong></li></ul><p>在编辑的时候有多少个空行(只要这一行只有回车或者space没有其他的字符就算空行)，在<strong>渲染之后，只隔着一行</strong>。</p><ul><li><strong>对齐方式</strong></li></ul><p>代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span>行中心对齐<span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>行左对齐<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>行右对齐<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>显示效果：</p><center>行中心对齐</center><p align="left">行左对齐</p><p align="right">行右对齐</p><h3 id="四、字体"><a href="#四、字体" class="headerlink" title="四、字体"></a>四、字体</h3><p>Markdown 可以使用以下几种字体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs none">*斜体文本*<br>_斜体文本_<br>**粗体文本**<br>__粗体文本__<br>***粗斜体文本***<br>___粗斜体文本___Copy<br></code></pre></td></tr></table></figure><p><strong>显示效果</strong>：</p><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em></p><h3 id="五、分割线"><a href="#五、分割线" class="headerlink" title="五、分割线"></a>五、分割线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">**** * ******- - -----------<br></code></pre></td></tr></table></figure><p>显示效果都一样</p><h3 id="六、删除线"><a href="#六、删除线" class="headerlink" title="六、删除线"></a>六、删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <strong>~~</strong> 即可，实例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">我是正常的~~我是删除线~~<br></code></pre></td></tr></table></figure><p><del>我是删除线</del></p><h3 id="七、下划线"><a href="#七、下划线" class="headerlink" title="七、下划线"></a>七、下划线</h3><p>下划线可以通过 HTML 的 标签来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">&lt;u&gt;我是下划线&lt;/u&gt;<br></code></pre></td></tr></table></figure><p>显示效果如下所示：</p><p><u>我是下划线</u></p><h3 id="八、脚注"><a href="#八、脚注" class="headerlink" title="八、脚注"></a>八、脚注</h3><p>脚注是对文本的补充说明，Markdown 脚注的格式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">[^我是脚注]<br></code></pre></td></tr></table></figure><p>以下实例演示了脚注的用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">创建脚注格式类似这样 [^RUNOOB]。[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！<br></code></pre></td></tr></table></figure><p>演示效果如下：</p><p>创建脚注格式类似这样 [<a href="https://www.cnblogs.com/miki-peng/articles/12502985.html#fn1">1]</a>。</p><h3 id="九、列表"><a href="#九、列表" class="headerlink" title="九、列表"></a>九、列表</h3><p>Markdown 支持有序列表和无序列表。</p><h4 id="1、无序列表"><a href="#1、无序列表" class="headerlink" title="1、无序列表"></a>1、无序列表</h4><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">* 第一项* 第二项* 第三项------ 分割线 ------+ 第一项+ 第二项+ 第三项------ 分割线 ------- 第一项- 第二项- 第三项<br></code></pre></td></tr></table></figure><p>显示结果如下：</p><ul><li>第一项</li><li>第二项</li><li>第三项<br>—— 分割线 ——</li><li>第一项</li><li>第二项</li><li>第三项<br>—— 分割线 ——</li><li>第一项</li><li>第二项</li><li>第三项</li></ul><h4 id="2、有序列表"><a href="#2、有序列表" class="headerlink" title="2、有序列表"></a>2、有序列表</h4><p>使用数字并加上 <strong>.</strong> 号来表示，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">1. 第一项2. 第二项3. 第三项<br></code></pre></td></tr></table></figure><p>显示结果如下：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h4 id="3、列表嵌套"><a href="#3、列表嵌套" class="headerlink" title="3、列表嵌套"></a>3、列表嵌套</h4><p>列表嵌套只需在子列表中的选项添加四个空格即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素<br></code></pre></td></tr></table></figure><p>显示结果如下：</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h3 id="十、区块"><a href="#十、区块" class="headerlink" title="十、区块"></a>十、区块</h3><h4 id="1、区块引用"><a href="#1、区块引用" class="headerlink" title="1、区块引用"></a>1、区块引用</h4><p>Markdown 区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">&gt; 区块引用&gt; 菜鸟教程&gt; 学的不仅是技术更是梦想<br></code></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>区块引用<br>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote><h4 id="2、区块中使用列表"><a href="#2、区块中使用列表" class="headerlink" title="2、区块中使用列表"></a>2、区块中使用列表</h4><p>区块中使用列表实例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项<br></code></pre></td></tr></table></figure><p>显示结果如下：</p><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h4 id="3、列表中使用区块"><a href="#3、列表中使用区块" class="headerlink" title="3、列表中使用区块"></a>3、列表中使用区块</h4><p>如果要在列表项目内放进区块，那么就需要在 <strong>&gt;</strong> 前添加四个空格的缩进。</p><p>区块中使用列表实例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">* 第一项    &gt; 菜鸟教程    &gt; 学的不仅是技术更是梦想* 第二项<br></code></pre></td></tr></table></figure><p>显示结果如下：</p><ul><li><p>第一项</p><blockquote><p>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote></li><li><p>第二项</p></li></ul><h4 id="4、多级引用"><a href="#4、多级引用" class="headerlink" title="4、多级引用"></a>4、多级引用</h4><p>语法说明：</p><p>引用需要在被引用的文本前加上&gt;符号和空格，允许多层嵌套，也允许你偷懒只在整个段落的第一行最前面加上 &gt; 。</p><p>代码：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&gt;&gt;&gt; 请问 Markdwon 怎么用？ - 小白&gt;&gt; 自己看教程！ - 愤青&gt; 教程在哪？ - 小白<br></code></pre></td></tr></table></figure><p>显示效果：</p><blockquote><blockquote><blockquote><p>请问 Markdwon 怎么用？ - 小白</p></blockquote></blockquote></blockquote><blockquote><blockquote><p>自己看教程！ - 愤青</p></blockquote></blockquote><blockquote><p>教程在哪？ - 小白</p></blockquote><h3 id="十一、代码"><a href="#十一、代码" class="headerlink" title="十一、代码"></a>十一、代码</h3><h4 id="1、单行代码"><a href="#1、单行代码" class="headerlink" title="1、单行代码"></a>1、单行代码</h4><p>如果是单行代码或段落上的一个函数或片段的代码可以用反引号把它包起来（**&#96;**），例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">`printf()` 函数<br></code></pre></td></tr></table></figure><p>显示结果如下：</p><p><code>printf()</code> 函数</p><h4 id="2、代码区块"><a href="#2、代码区块" class="headerlink" title="2、代码区块"></a>2、代码区块</h4><p>代码区块使用三个反引号对**&#96;&#96;&#96;** 包裹一段代码，并指定一种语言（也可以不指定）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CaseData</span>:    <span class="hljs-string">&quot;&quot;&quot;这是一个存放测试用例数据的类&quot;&quot;&quot;</span>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>显示结果如下：</p><p>class CaseData:<br>“””这是一个存放测试用例数据的类”””<br>pass</p><h3 id="十二、链接"><a href="#十二、链接" class="headerlink" title="十二、链接"></a>十二、链接</h3><h4 id="1、使用方法："><a href="#1、使用方法：" class="headerlink" title="1、使用方法："></a>1、使用方法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">[链接名称](链接地址)或者&lt;链接地址&gt;Copy<br></code></pre></td></tr></table></figure><p>例如：</p><p>这是一个链接 <a href="https://codeanime.cn/">我是链接</a></p><p>直接使用链接地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">&lt;https://codeanime.cn&gt;Copy<br></code></pre></td></tr></table></figure><p>显示结果如下：</p><p><a href="https://codeanime.cn/">https://codeanime.cn</a></p><h4 id="2、高级链接"><a href="#2、高级链接" class="headerlink" title="2、高级链接"></a>2、高级链接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">链接也可以用变量来代替，文档末尾附带变量地址：这个链接用 1 作为网址变量 [Google][1]这个链接用 runoob 作为网址变量 [Runoob][runoob]然后在文档的结尾为变量赋值（网址）  [1]: http://www.google.com/  [runoob]: http://www.runoob.com/<br></code></pre></td></tr></table></figure><p>显示结果如下：</p><p>链接也可以用变量来代替，文档末尾附带变量地址：</p><p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a></p><p>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a></p><p>然后在文档的结尾为变量赋值（网址）</p><h3 id="十三、图片"><a href="#十三、图片" class="headerlink" title="十三、图片"></a>十三、图片</h3><p>Markdown 图片语法格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)<br></code></pre></td></tr></table></figure><ul><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</li></ul><p>使用实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">![RUNOOB 图标](https://www.cnblogs.com/images/logo_small.gif)![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;)<br></code></pre></td></tr></table></figure><p>当然，你也可以像网址那样对图片网址使用变量:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">这个链接用 1 作为网址变量 [RUNOOB][1].然后在文档的结尾位变量赋值（网址）[1]: http://static.runoob.com/images/runoob-logo.png<br></code></pre></td></tr></table></figure><p>显示结果如下：</p><p>这个链接用 1 作为网址变量 [RUNOOB][1].然后在文档的结尾位变量赋值（网址）[1]: <a href="http://static.runoob.com/images/runoob-logo.png">http://static.runoob.com/images/runoob-logo.png</a></p><p>然后在文档的结尾位变量赋值（网址）</p><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的标签。<br><code>&lt;img src=&quot;http://static.runoob.com/images/runoob-logo.png&quot; width=&quot;50%&quot;&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">&lt;img src=&quot;http://static.runoob.com/images/runoob-logo.png&quot; width=&quot;50%&quot;&gt;<br></code></pre></td></tr></table></figure><h3 id="十四、表格"><a href="#十四、表格" class="headerlink" title="十四、表格"></a>十四、表格</h3><p>Markdown 制作表格使用 <strong>|</strong> 来分隔不同的单元格，使用 <strong>-</strong> 来分隔表头和其他行。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |<br></code></pre></td></tr></table></figure><p>以上代码显示结果如下：</p><table><thead><tr><th align="left">表头</th><th align="left">表头</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="left">单元格</td></tr><tr><td align="left">单元格</td><td align="left">单元格</td></tr></tbody></table><p>对齐方式</p><p><strong>我们可以设置表格的对齐方式：</strong></p><ul><li><strong>-:</strong> 设置内容和标题栏居右对齐。</li><li><strong>:-</strong> 设置内容和标题栏居左对齐。</li><li><strong>:-:</strong> 设置内容和标题栏居中对齐。</li></ul><p>实例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |<br></code></pre></td></tr></table></figure><p>以上代码显示结果如下：</p><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h3 id="十五、高级技巧"><a href="#十五、高级技巧" class="headerlink" title="十五、高级技巧"></a>十五、高级技巧</h3><h4 id="1、支持HTML元素"><a href="#1、支持HTML元素" class="headerlink" title="1、支持HTML元素"></a>1、支持HTML元素</h4><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有：<code> </code>等 ，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑<br></code></pre></td></tr></table></figure><p>输出结果为：</p><p>使用 Ctrl+Alt+Del 重启电脑</p><h4 id="2、转义"><a href="#2、转义" class="headerlink" title="2、转义"></a>2、转义</h4><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">**文本加粗** \*\* 正常显示星号 \*\*<br></code></pre></td></tr></table></figure><p>输出结果为：</p><p><strong>文本加粗</strong></p><p>** 正常显示星号 **</p><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">\   反斜线`   反引号*   星号_   下划线&#123;&#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号<br></code></pre></td></tr></table></figure><h4 id="3、流程图"><a href="#3、流程图" class="headerlink" title="3、流程图"></a>3、流程图</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">``</span><span class="hljs-string">`graph LRA--&gt;B`</span><span class="hljs-string">``</span><span class="hljs-string">``</span><span class="hljs-string">`sequenceDiagramA-&gt;&gt;B: How are you?B-&gt;&gt;A: Great!`</span><span class="hljs-string">``</span>Copy<br></code></pre></td></tr></table></figure><p>显示效果：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">graph LRA--&gt;B<br>sequenceDiagramA-&gt;&gt;B: How are you?B-&gt;&gt;A: Great!<br></code></pre></td></tr></table></figure><h4 id="4、LaTex公式"><a href="#4、LaTex公式" class="headerlink" title="4、LaTex公式"></a>4、LaTex公式</h4><p>代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">质能守恒方程可以用一个很简洁的方程式 `<span class="hljs-variable">$E</span> = m c^2 $`来表达。<br></code></pre></td></tr></table></figure><p>显示效果：</p><p>质能守恒方程可以用一个很简洁的方程式 <code>$E = m c^2 $</code>来表达。</p><ul><li><strong>表示整行公式</strong><br>大部分的浏览器支持的</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$$</span> 公式 <span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure><p>有道云笔记 使用格式，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">``</span><span class="hljs-string">`mathE = mc^2`</span><span class="hljs-string">``</span><br></code></pre></td></tr></table></figure><p>块级公式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">``</span><span class="hljs-string">`mathx = \dfrac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; `</span><span class="hljs-string">``</span><span class="hljs-string">``</span><span class="hljs-string">`math[\frac&#123;1&#125;&#123;\Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;\frac25 \pi&#125;&#125; =1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-6\pi&#125;&#125;&#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125; &#123;1+\ldots&#125; &#125; &#125; &#125;]`</span><span class="hljs-string">``</span><br></code></pre></td></tr></table></figure><p>显示效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs math">x = \dfrac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; Copy<br>[\frac&#123;1&#125;&#123;\Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;\frac25 \pi&#125;&#125; =1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-6\pi&#125;&#125;&#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125; &#123;1+\ldots&#125; &#125; &#125; &#125;]<br></code></pre></td></tr></table></figure><p>访问 <a href="https://links.jianshu.com/go?to=https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">MathJax</a> 参考更多使用方法。</p><h4 id="5、特殊字符"><a href="#5、特殊字符" class="headerlink" title="5、特殊字符"></a>5、特殊字符</h4><table><thead><tr><th align="center">特殊字符</th><th align="center">描述</th><th align="center">字符的代码</th></tr></thead><tbody><tr><td align="center"></td><td align="center">空格符</td><td align="center">&#96;&#96;</td></tr><tr><td align="center">&lt;</td><td align="center">小于号</td><td align="center"><code>&lt;</code></td></tr><tr><td align="center">&gt;</td><td align="center">大于号</td><td align="center"><code>&gt;</code></td></tr><tr><td align="center">&amp;</td><td align="center">和号</td><td align="center"><code>&amp;</code></td></tr><tr><td align="center">￥</td><td align="center">人民币</td><td align="center"><code>¥</code></td></tr><tr><td align="center">©</td><td align="center">版权</td><td align="center"><code>©</code></td></tr><tr><td align="center">®</td><td align="center">注册商标</td><td align="center"><code>®</code></td></tr><tr><td align="center">°C</td><td align="center">摄氏度</td><td align="center"><code>°C</code></td></tr><tr><td align="center">±</td><td align="center">正负号</td><td align="center"><code>±</code></td></tr><tr><td align="center">×</td><td align="center">乘号</td><td align="center"><code>×</code></td></tr><tr><td align="center">÷</td><td align="center">除号</td><td align="center"><code>÷</code></td></tr><tr><td align="center">²</td><td align="center">平方（上标²）</td><td align="center"><code>²</code></td></tr><tr><td align="center">³</td><td align="center">立方（上标³）</td><td align="center"><code>³</code></td></tr></tbody></table><h3 id="十六、文字颜色、大小、字体"><a href="#十六、文字颜色、大小、字体" class="headerlink" title="十六、文字颜色、大小、字体"></a>十六、文字颜色、大小、字体</h3><h4 id="1、颜色"><a href="#1、颜色" class="headerlink" title="1、颜色"></a>1、颜色</h4><p>在markdown中采用如下方式能够控制文字的颜色：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">&lt;font color=&quot;#dd0000&quot;&gt;文字颜色预览&lt;/font&gt;<br></code></pre></td></tr></table></figure><h4 id="2、字体大小"><a href="#2、字体大小" class="headerlink" title="2、字体大小"></a>2、字体大小</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">size为1：&lt;font size=&quot;1&quot;&gt;size为1&lt;/font&gt;size为2：&lt;font size=&quot;2&quot;&gt;size为2&lt;/font&gt;size为3：&lt;font size=&quot;3&quot;&gt;size为3&lt;/font&gt;size为4：&lt;font size=&quot;4&quot;&gt;size为4&lt;/font&gt;size为6：&lt;font size=&quot;6&quot;&gt;size为6&lt;/font&gt;<br></code></pre></td></tr></table></figure><p>效果如下：</p><p>size为1：<font size="1">size为1</font></p><p>size为2：<font size="2">size为2</font></p><p>size为3：<font size="3">size为3</font></p><p>size为4：<font size="4">size为4</font></p><p>size为6：<font size="6">size为6</font></p><h4 id="3、字体"><a href="#3、字体" class="headerlink" title="3、字体"></a>3、字体</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt; &lt;font face=&quot;宋体&quot;&gt;我是宋体字&lt;/font&gt; &lt;font face=&quot;楷体&quot;&gt;我是楷体字&lt;/font&gt; &lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑字&lt;/font&gt; &lt;font face=&quot;fantasy&quot;&gt;我是fantasy字&lt;/font&gt;&lt;font face=&quot;Helvetica&quot;&gt;我是Helvetica字&lt;/font&gt;<br></code></pre></td></tr></table></figure><p>效果如下：</p><p><font face="黑体">我是黑体字</font></p><p> <font face="宋体">我是宋体字</font> </p><p><font face="楷体">我是楷体字</font> </p><p><font face="微软雅黑">我是微软雅黑字</font></p><p> <font face="fantasy">我是fantasy字</font></p><p><font face="Helvetica">我是Helvetica字</font> </p><h4 id="4、背景色"><a href="#4、背景色" class="headerlink" title="4、背景色"></a>4、背景色</h4><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#F4A460&gt;背景色的设置是按照十六进制颜色值：#F4A460&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FF6347&gt;背景色的设置是按照十六进制颜色值：#FF6347&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;  &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#D8BFD8&gt;背景色的设置是按照十六进制颜色值：#D8BFD8&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;  &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#008080&gt;背景色的设置是按照十六进制颜色值：#008080&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;  &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FFD700&gt;背景色的设置是按照十六进制颜色值：#FFD700&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;<br></code></pre></td></tr></table></figure><p>效果如下：</p><table><tr><td bgcolor=#F4A460>背景色的设置是按照十六进制颜色值：#F4A460</td></tr></table><table><tr><td bgcolor=#FF6347>背景色的设置是按照十六进制颜色值：#FF6347</td></tr></table>  <table><tr><td bgcolor=#D8BFD8>背景色的设置是按照十六进制颜色值：#D8BFD8</td></tr></table>  <table><tr><td bgcolor=#008080>背景色的设置是按照十六进制颜色值：#008080</td></tr></table>  <table><tr><td bgcolor=#FFD700>背景色的设置是按照十六进制颜色值：#FFD700</td></tr></table><p>参考:</p><ul><li><a href="https://www.cnblogs.com/miki-peng/articles/12502985.html">markdown语法大全</a> [作者]</li><li><a href="https://yorg.top/Markdown.html">Markdown语法笔记</a>[咳咳怪]</li><li><a href="https://codeanime.cc/Markdown%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89.html">Markdown语法大全</a>[codeanime]</li><li><a href="https://www.jianshu.com/p/ebe52d2d468f">Markdown语法大全(超级版)</a>[择势量投]</li></ul>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Markdown语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo搭建及部署</title>
    <link href="/2022/04/25/Hexo%E6%90%AD%E5%BB%BA%E5%8F%8A%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/04/25/Hexo%E6%90%AD%E5%BB%BA%E5%8F%8A%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-搭建及部署-更新中"><a href="#Hexo-搭建及部署-更新中" class="headerlink" title="Hexo 搭建及部署(更新中)"></a>Hexo 搭建及部署(更新中)</h1><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><h4 id="1、-Hexo特点"><a href="#1、-Hexo特点" class="headerlink" title="1、 Hexo特点"></a>1、 Hexo特点</h4><p>Hexo 是一个简单、快速、强大的静态博客框架,出自台湾大学生 tommy351 之手。我也看过使用 Jekyll、Octopress 搭建个人博客的过程，确实要繁琐许多。相比之下 Hexo 更轻便更快捷，下面是其官网强调的四大特点：</p><ul><li>极速生成静态页面</li><li>一键部署博客</li><li>丰富的插件支持</li><li>支持 Markdown</li></ul><h3 id="二-下载安装环境"><a href="#二-下载安装环境" class="headerlink" title="二.下载安装环境"></a>二.下载安装环境</h3><h4 id="1、下载安装Node-js-amp-amp-npm"><a href="#1、下载安装Node-js-amp-amp-npm" class="headerlink" title="1、下载安装Node.js &amp;&amp; npm"></a>1、下载安装Node.js &amp;&amp; npm</h4><ol><li><p><a href="https://nodejs.org/">Node.js 官网</a> || <a href="http://nodejs.cn/">Node.js 中文网 (nodejs.cn)</a></p><ul><li><p>安装完Node.js后可以用命令行查询是否有安装成功</p></li><li><p>使用 node -v 可以查询到当前安装的node版本</p></li><li><p>npm会在nodejs下载安装完之后自动安装，可在命令行自行查询</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查安装是否成功</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git -v</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">node -v</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">npm -v</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">更换下载源（提高下载速度）</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="二、下载使用Hexo"><a href="#二、下载使用Hexo" class="headerlink" title="二、下载使用Hexo"></a>二、下载使用Hexo</h3><h4 id="1、安装Hexo"><a href="#1、安装Hexo" class="headerlink" title="1、安装Hexo"></a>1、安装Hexo</h4><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br># <span class="hljs-number">1</span>、安装 hexo<br>$ npm install -g hexo-cli<br><br># <span class="hljs-number">2</span>、新建工作目录，存放hexo的配置文件、主题、博客（自己写的）等<br>$ mkdir blog/<br>$ cd blog/<br><br># <span class="hljs-number">3</span>、初始化hexo环境(必须进入一个空目录进行初始化！)<br>$ hexo init<br><br>##########  至此，hexo安装完成！ #########<br><br></code></pre></td></tr></table></figure><h4 id="2、使用Hexo"><a href="#2、使用Hexo" class="headerlink" title="2、使用Hexo"></a>2、使用Hexo</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1、新建博客文件，生成的文件存放在 blog/source/_post/文件名.md</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo nwe <span class="hljs-string">&#x27;文件名&#x27;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2、自定义“文件名.md”内容</span><br>使用本地markdown工具进行编辑<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3、文件渲染</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo g</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4、本地环境测试（hexo提供的测试服务器，将本地编写的博客文件渲染并展示）</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo s  <span class="hljs-comment">#（浏览器输入：localhost:4000即可查看）</span></span><br><br></code></pre></td></tr></table></figure><h4 id="3、创建个人GitHub-io仓库"><a href="#3、创建个人GitHub-io仓库" class="headerlink" title="3、创建个人GitHub.io仓库"></a>3、创建个人GitHub.io仓库</h4><p>   登录到GitHub,如果没有GitHub帐号，使用你的邮箱注册GitHub帐号，点击GitHub中的New repository创建新仓库，仓库名应该为：<strong>用户名</strong>.<a href="https://link.zhihu.com/?target=http://github.io">http://github.io</a> 这个<strong>用户名</strong>使用你的GitHub帐号名称代替，这是固定写法，比如我的仓库名为：</p><p><img src="https://cdn.jsdelivr.net/gh/linyin022/image@main/Hexo_img/githubio.png"></p><h4 id="4、安装Git"><a href="#4、安装Git" class="headerlink" title="4、安装Git"></a>4、安装Git</h4><p>什么是Git ?简单来说Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。如果想要了解Git的细节，参看<a href="https://link.zhihu.com/?target=http://weibo.com/liaoxuefeng">廖雪峰</a>老师的Git教程：<a href="https://link.zhihu.com/?target=http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程</a> 从Git官网下载：<a href="https://link.zhihu.com/?target=https://git-scm.com/download/win">Git - Downloading Package</a> 现在的机子基本都是64位的，选择64位的安装包，下载后安装，在命令行里输入git测试是否安装成功，若安装失败，参看其他详细的Git安装教程。安装成功后，将你的Git与GitHub帐号绑定，鼠标右击打开Git Bash</p><p><img src="https://cdn.jsdelivr.net/gh/linyin022/image@main/Hexo_img/git_bash.jpg"></p><p>或者在菜单里搜索Git Bash，设置user.name和user.email配置信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;你的GitHub用户名&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;你的GitHub注册邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>生成ssh密钥文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;你的GitHub注册邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>然后直接三个回车即可，默认不需要设置密码<br>然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制</p><p><img src="https://cdn.jsdelivr.net/gh/linyin022/image@main/Hexo_img/id_rsa.jpg"></p><p>打开<a href="https://link.zhihu.com/?target=https://github.com/settings/keys">GitHub_Settings_keys</a> 页面，新建new SSH Key</p><p><img src="https://cdn.jsdelivr.net/gh/linyin022/image@main/Hexo_img/githubkey.jpg"></p><p>Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。<br>在Git Bash中检测GitHub公钥设置是否成功，输入 ssh <a href="mailto:&#x67;&#105;&#116;&#x40;&#x67;&#x69;&#x74;&#104;&#117;&#x62;&#x2e;&#x63;&#x6f;&#x6d;">&#x67;&#105;&#116;&#x40;&#x67;&#x69;&#x74;&#104;&#117;&#x62;&#x2e;&#x63;&#x6f;&#x6d;</a> </p><p><img src="https://cdn.jsdelivr.net/gh/linyin022/image@main/Hexo_img/ssh_key.jpg"></p><p>如上则说明成功。这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。</p><h4 id="5、Hexo部署"><a href="#5、Hexo部署" class="headerlink" title="5、Hexo部署"></a>5、Hexo部署</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><br><span class="hljs-comment"># 1、安装 hexo-githubPage 插件</span><br>npm install --save hexo-deployer-git<br><br><span class="hljs-comment"># 2、新建仓库，名称必须为：&#123;github用户名&#125;.github.io</span><br><br><span class="hljs-comment"># 3、复制该仓库的路径</span><br><br><span class="hljs-comment"># 4、编辑 blog/_config.yml文件</span><br><br><span class="hljs-symbol">url:</span> url路径<br><span class="hljs-symbol">permalink:</span> <span class="hljs-symbol">:year/</span><span class="hljs-symbol">:month/</span><span class="hljs-symbol">:day/</span><span class="hljs-symbol">:title/</span><br><span class="hljs-symbol">permalink_defaults:</span><br><span class="hljs-symbol">pretty_urls:</span><br>  <span class="hljs-symbol">trailing_index:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-symbol">trailing_html:</span> <span class="hljs-literal">true</span> <br><br><span class="hljs-symbol">deploy:</span><br>  <span class="hljs-symbol">type:</span> <span class="hljs-string">&#x27;git&#x27;</span><br>  <span class="hljs-symbol">repo:</span> <span class="hljs-string">&#x27;仓库地址&#x27;</span><br>  <span class="hljs-symbol">branch:</span> <span class="hljs-string">&#x27;分支名&#x27;</span><br><br><span class="hljs-comment"># 5、部署到github page</span><br><span class="hljs-variable">$ </span>hexo d<br><br></code></pre></td></tr></table></figure><h4 id="6、Hexo个性化"><a href="#6、Hexo个性化" class="headerlink" title="6、Hexo个性化"></a>6、Hexo个性化</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1、从github克隆第三方主题，保存到：blog/theme/主题名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2、配置 blog/_config.yml文件</span><br>theme: 主题名字<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3、保存提出</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo clean  <span class="hljs-comment"># 清空缓存</span></span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo g <span class="hljs-comment"># 重新渲染</span></span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo s <span class="hljs-comment"># 测试用</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo d <span class="hljs-comment"># 部署到github page</span></span><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Git</tag>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用GitHub+jsDelivr[第三方CDN加速]创建属于自己的床图</title>
    <link href="/2022/04/22/%E5%88%A9%E7%94%A8GItHub-jsDelivr-%E7%AC%AC%E4%B8%89%E6%96%B9CDN%E5%8A%A0%E9%80%9F-%E5%88%9B%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%8A%E5%9B%BE/"/>
    <url>/2022/04/22/%E5%88%A9%E7%94%A8GItHub-jsDelivr-%E7%AC%AC%E4%B8%89%E6%96%B9CDN%E5%8A%A0%E9%80%9F-%E5%88%9B%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%8A%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文章转载自[烟雨星空]的文章并且二次简化修改<br>原文章：<a href="https://www.cnblogs.com/starry-skys/p/13905766.html">https://www.cnblogs.com/starry-skys/p/13905766.html</a></p></blockquote><p><strong>1. 创建一个GitHub仓库[任意名字]</strong><br><strong>2. 在仓库中上传你的图片</strong><br><strong>3. 使用jsDelivr加速访问GitHub的床图</strong></p><p><img src="https://xiaoke022.ml/usr/uploads/2022/04/3086131500.png" alt="l1rymp2g.png"><br>创建好床图之后如果想要原生查看床图就进入任意图片，后查看url，<br>例如<br><img src="https://xiaoke022.ml/usr/uploads/2022/04/1783989775.png" alt="l1ryop33.png"><br>这是我当前的床图中的一个logo，他的url地址为：</p><blockquote><p><a href="https://github.com/linyin022/image/blob/main/logo.png">https://github.com/linyin022/image/blob/main/logo.png</a></p></blockquote><p>如果想要使用原生床图就将url路径中的blob修改成raw。或者是在原本的url路径末尾加上?raw&#x3D;true。以下是两种原生查看床图的方法实例</p><p><a href="https://github.com/linyin022/image/raw/main/logo.png">https://github.com/linyin022/image/raw/main/logo.png</a><br><a href="https://github.com/linyin022/image/blob/main/logo.png?raw=true">https://github.com/linyin022/image/blob/main/logo.png?raw=true</a></p><p>如果使用GitHub的原生床图访问速度非常慢。我们就得利用cdn来加速实现快速访问。</p><p><strong>使用jsDelivr实现CDN加速</strong></p><p>jsDelivr是一个开源免费的CDN床图加速项目</p><p>使用的方法为以下：<br>jsDelivr的路径为</p><blockquote><p><a href="https://cdn.jsdelivr.net/gh/">https://cdn.jsdelivr.net/gh/</a>&lt;你的github用户名&gt;&#x2F;&lt;你的图床仓库名&gt;@&lt;仓库版本号&gt;&#x2F;图片的路径</p></blockquote><p>这是我GitHub的logo床图的url路径<br><img src="https://xiaoke022.ml/usr/uploads/2022/04/4124722373.png" alt="l1rzm3zc.png"></p><p>将这些url路径修改进jsDelivr中，路径就是为：</p><blockquote><p><a href="https://cdn.jsdelivr.net/gh/linyin022/image@main/logo.png">https://cdn.jsdelivr.net/gh/linyin022/image@main/logo.png</a></p></blockquote><p>👆可以点击查看并且cdn加速之后的链接是否有比GitHub原生查看图片有更快的访问速度</p><p>总结：</p><ul><li>使用CDN加速可以实现某些图片、文件、资源等等使用国内网络时访问速度过慢或者无法打开时，使用CDN加速可以帮助我们有效更快的访问。</li></ul><blockquote><p>以下介绍什么是CDN及CDN加速原理[全部转载自网络搜索]</p></blockquote><p>CDN的全称是(Content Delivery Network)，即内容分发网络。其目的是通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因，提高用户访问网站的响应速度。<br>简单的说，CDN的工作原理就是将您源站的资源缓存到位于全球各地的CDN节点上，用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都回您的源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验</p><p><img src="https://xiaoke022.ml/usr/uploads/2022/04/2718497112.png" alt="l1s03z54.png"><br><img src="https://xiaoke022.ml/usr/uploads/2022/04/210631655.png" alt="l1s04e9j.png"><br><img src="https://xiaoke022.ml/usr/uploads/2022/04/884058262.png" alt="l1s04ze9.png"><br><img src="https://xiaoke022.ml/usr/uploads/2022/04/3127988837.png" alt="l1s057di.png"></p>]]></content>
    
    
    <categories>
      
      <category>Github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>GitHub</tag>
      
      <tag>jsDelivr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThinkPHP6-Notes</title>
    <link href="/2022/04/19/ThinkPHP6-Notes/"/>
    <url>/2022/04/19/ThinkPHP6-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="ThinkPHP6-Notes"><a href="#ThinkPHP6-Notes" class="headerlink" title="ThinkPHP6-Notes"></a>ThinkPHP6-Notes</h1><h2 id="View-视图"><a href="#View-视图" class="headerlink" title="View-视图"></a>View-视图</h2><table><thead><tr><th align="left">运算符</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">{$a+$b}</td></tr><tr><td align="left">-</td><td align="left">{$a-$b}</td></tr><tr><td align="left">*</td><td align="left">{$a*$b}</td></tr><tr><td align="left">&#x2F;</td><td align="left">{$a&#x2F;$b}</td></tr><tr><td align="left">%</td><td align="left">{$a%$b}</td></tr><tr><td align="left">++</td><td align="left">{$a++} 或 {++$a}</td></tr><tr><td align="left">–</td><td align="left">{$a–} 或{–$a}</td></tr><tr><td align="left">综合运算</td><td align="left">{$a+$b*10+$c}</td></tr><tr><td align="left">三元运算符</td><td align="left">{$a&#x3D;&#x3D;$b ? ‘yes’ : ‘no’}</td></tr></tbody></table><p><strong>Controller文件</strong></p><figure class="highlight php"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">app</span>\<span class="hljs-title class_">controller</span>;<br><span class="hljs-keyword">use</span> <span class="hljs-title">app</span>\<span class="hljs-title">BaseController</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseController</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello ThinkPHP6!&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>这一段代码是直接输出返回 hello ThinkPHP6!</em></p><p>如若需要输出html页面请更换代码&#x3D;&gt;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">app</span>\<span class="hljs-title class_">controller</span>;<br><span class="hljs-keyword">use</span> <span class="hljs-title">app</span>\<span class="hljs-title">BaseController</span>;<br><span class="hljs-keyword">use</span> <span class="hljs-title">think</span>\<span class="hljs-title">fecade</span>\<span class="hljs-title">View</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseController</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-title class_">View</span>::<span class="hljs-title function_ invoke__">fetch</span>(<span class="hljs-string">&#x27;Index&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里的View是门面的模块-&gt;fecade</li></ul><p><strong>View文件</strong></p><ul><li><p>View&#x2F;[class_name]&#x2F;[fetch[‘name’]]</p></li><li><p>View&#x2F;index&#x2F;index.html</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>ThinkPHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ThinkPHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/15/hello-world/"/>
    <url>/2022/04/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
